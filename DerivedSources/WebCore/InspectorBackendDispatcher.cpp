// File is generated by Source/WebCore/inspector/CodeGeneratorInspector.py

// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


#include "config.h"

#if ENABLE(INSPECTOR)

#include "InspectorBackendDispatcher.h"
#include <wtf/text/WTFString.h>
#include <wtf/text/CString.h>

#include "InspectorAgent.h"
#include "InspectorValues.h"
#include "InspectorFrontendChannel.h"
#include <wtf/text/WTFString.h>

namespace WebCore {

const char* InspectorBackendDispatcher::commandNames[] = {
    "Inspector.enable",
    "Inspector.disable",
    "Memory.getDOMNodeCount",
    "Page.enable",
    "Page.disable",
    "Page.addScriptToEvaluateOnLoad",
    "Page.removeScriptToEvaluateOnLoad",
    "Page.reload",
    "Page.navigate",
    "Page.getCookies",
    "Page.deleteCookie",
    "Page.getResourceTree",
    "Page.getResourceContent",
    "Page.searchInResource",
    "Page.searchInResources",
    "Page.setDocumentContent",
    "Page.setScreenSizeOverride",
    "Page.setShowPaintRects",
    "Runtime.evaluate",
    "Runtime.callFunctionOn",
    "Runtime.getProperties",
    "Runtime.releaseObject",
    "Runtime.releaseObjectGroup",
    "Runtime.run",
    "Console.enable",
    "Console.disable",
    "Console.clearMessages",
    "Console.setMonitoringXHREnabled",
    "Console.addInspectedNode",
    "Console.addInspectedHeapObject",
    "Network.enable",
    "Network.disable",
    "Network.setUserAgentOverride",
    "Network.setExtraHTTPHeaders",
    "Network.getResponseBody",
    "Network.canClearBrowserCache",
    "Network.clearBrowserCache",
    "Network.canClearBrowserCookies",
    "Network.clearBrowserCookies",
    "Network.setCacheDisabled",
#if ENABLE(SQL_DATABASE)

    "Database.enable",
    "Database.disable",
    "Database.getDatabaseTableNames",
    "Database.executeSQL",
#endif // ENABLE(SQL_DATABASE)

#if ENABLE(INDEXED_DATABASE)

    "IndexedDB.enable",
    "IndexedDB.disable",
    "IndexedDB.requestDatabaseNamesForFrame",
    "IndexedDB.requestDatabase",
    "IndexedDB.requestData",
#endif // ENABLE(INDEXED_DATABASE)

    "DOMStorage.enable",
    "DOMStorage.disable",
    "DOMStorage.getDOMStorageEntries",
    "DOMStorage.setDOMStorageItem",
    "DOMStorage.removeDOMStorageItem",
    "ApplicationCache.getFramesWithManifests",
    "ApplicationCache.enable",
    "ApplicationCache.getManifestForFrame",
    "ApplicationCache.getApplicationCacheForFrame",
#if ENABLE(FILE_SYSTEM)

    "FileSystem.enable",
    "FileSystem.disable",
#endif // ENABLE(FILE_SYSTEM)

    "DOM.getDocument",
    "DOM.requestChildNodes",
    "DOM.querySelector",
    "DOM.querySelectorAll",
    "DOM.setNodeName",
    "DOM.setNodeValue",
    "DOM.removeNode",
    "DOM.setAttributeValue",
    "DOM.setAttributesAsText",
    "DOM.removeAttribute",
    "DOM.getEventListenersForNode",
    "DOM.getOuterHTML",
    "DOM.setOuterHTML",
    "DOM.performSearch",
    "DOM.getSearchResults",
    "DOM.discardSearchResults",
    "DOM.requestNode",
    "DOM.setInspectModeEnabled",
    "DOM.highlightRect",
    "DOM.highlightNode",
    "DOM.hideHighlight",
    "DOM.highlightFrame",
    "DOM.pushNodeByPathToFrontend",
    "DOM.resolveNode",
    "DOM.getAttributes",
    "DOM.moveTo",
    "DOM.setTouchEmulationEnabled",
    "DOM.undo",
    "DOM.redo",
    "DOM.markUndoableState",
    "CSS.enable",
    "CSS.disable",
    "CSS.getMatchedStylesForNode",
    "CSS.getInlineStylesForNode",
    "CSS.getComputedStyleForNode",
    "CSS.getAllStyleSheets",
    "CSS.getStyleSheet",
    "CSS.getStyleSheetText",
    "CSS.setStyleSheetText",
    "CSS.setPropertyText",
    "CSS.toggleProperty",
    "CSS.setRuleSelector",
    "CSS.addRule",
    "CSS.getSupportedCSSProperties",
    "CSS.startSelectorProfiler",
    "CSS.stopSelectorProfiler",
    "Timeline.start",
    "Timeline.stop",
    "Timeline.setIncludeMemoryDetails",
#if ENABLE(JAVASCRIPT_DEBUGGER)

    "Debugger.causesRecompilation",
    "Debugger.supportsNativeBreakpoints",
    "Debugger.enable",
    "Debugger.disable",
    "Debugger.setBreakpointsActive",
    "Debugger.setBreakpointByUrl",
    "Debugger.setBreakpoint",
    "Debugger.removeBreakpoint",
    "Debugger.continueToLocation",
    "Debugger.stepOver",
    "Debugger.stepInto",
    "Debugger.stepOut",
    "Debugger.pause",
    "Debugger.resume",
    "Debugger.searchInContent",
    "Debugger.canSetScriptSource",
    "Debugger.setScriptSource",
    "Debugger.getScriptSource",
    "Debugger.getFunctionDetails",
    "Debugger.setPauseOnExceptions",
    "Debugger.evaluateOnCallFrame",
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

#if ENABLE(JAVASCRIPT_DEBUGGER)

    "DOMDebugger.setDOMBreakpoint",
    "DOMDebugger.removeDOMBreakpoint",
    "DOMDebugger.setEventListenerBreakpoint",
    "DOMDebugger.removeEventListenerBreakpoint",
    "DOMDebugger.setInstrumentationBreakpoint",
    "DOMDebugger.removeInstrumentationBreakpoint",
    "DOMDebugger.setXHRBreakpoint",
    "DOMDebugger.removeXHRBreakpoint",
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

#if ENABLE(JAVASCRIPT_DEBUGGER)

    "Profiler.causesRecompilation",
    "Profiler.isSampling",
    "Profiler.hasHeapProfiler",
    "Profiler.enable",
    "Profiler.disable",
    "Profiler.start",
    "Profiler.stop",
    "Profiler.getProfileHeaders",
    "Profiler.getProfile",
    "Profiler.removeProfile",
    "Profiler.clearProfiles",
    "Profiler.takeHeapSnapshot",
    "Profiler.collectGarbage",
    "Profiler.getObjectByHeapObjectId",
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

#if ENABLE(WORKERS)

    "Worker.setWorkerInspectionEnabled",
    "Worker.sendMessageToWorker",
    "Worker.connectToWorker",
    "Worker.disconnectFromWorker",
    "Worker.setAutoconnectToWorkers",
#endif // ENABLE(WORKERS)

};


class InspectorBackendDispatcherImpl : public InspectorBackendDispatcher {
public:
    InspectorBackendDispatcherImpl(InspectorFrontendChannel* inspectorFrontendChannel)
        : m_inspectorFrontendChannel(inspectorFrontendChannel)
        , m_applicationCacheAgent(0)
        , m_cssAgent(0)
        , m_consoleAgent(0)
        , m_domAgent(0)
#if ENABLE(JAVASCRIPT_DEBUGGER)

        , m_domDebuggerAgent(0)
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

        , m_domStorageAgent(0)
#if ENABLE(SQL_DATABASE)

        , m_databaseAgent(0)
#endif // ENABLE(SQL_DATABASE)

#if ENABLE(JAVASCRIPT_DEBUGGER)

        , m_debuggerAgent(0)
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

#if ENABLE(FILE_SYSTEM)

        , m_fileSystemAgent(0)
#endif // ENABLE(FILE_SYSTEM)

#if ENABLE(INDEXED_DATABASE)

        , m_indexedDBAgent(0)
#endif // ENABLE(INDEXED_DATABASE)

        , m_inspectorAgent(0)
        , m_memoryAgent(0)
        , m_networkAgent(0)
        , m_pageAgent(0)
#if ENABLE(JAVASCRIPT_DEBUGGER)

        , m_profilerAgent(0)
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

        , m_runtimeAgent(0)
        , m_timelineAgent(0)
#if ENABLE(WORKERS)

        , m_workerAgent(0)
#endif // ENABLE(WORKERS)

    { }

    virtual void clearFrontend() { m_inspectorFrontendChannel = 0; }
    virtual void dispatch(const String& message);
    virtual void reportProtocolError(const long* const callId, CommonErrorCode, const String& errorMessage, PassRefPtr<InspectorArray> data) const;
    using InspectorBackendDispatcher::reportProtocolError;

    virtual void registerAgent(ApplicationCacheCommandHandler* applicationCacheAgent) { ASSERT(!m_applicationCacheAgent); m_applicationCacheAgent = applicationCacheAgent; }
    virtual void registerAgent(CSSCommandHandler* cssAgent) { ASSERT(!m_cssAgent); m_cssAgent = cssAgent; }
    virtual void registerAgent(ConsoleCommandHandler* consoleAgent) { ASSERT(!m_consoleAgent); m_consoleAgent = consoleAgent; }
    virtual void registerAgent(DOMCommandHandler* domAgent) { ASSERT(!m_domAgent); m_domAgent = domAgent; }
#if ENABLE(JAVASCRIPT_DEBUGGER)

    virtual void registerAgent(DOMDebuggerCommandHandler* domDebuggerAgent) { ASSERT(!m_domDebuggerAgent); m_domDebuggerAgent = domDebuggerAgent; }
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

    virtual void registerAgent(DOMStorageCommandHandler* domStorageAgent) { ASSERT(!m_domStorageAgent); m_domStorageAgent = domStorageAgent; }
#if ENABLE(SQL_DATABASE)

    virtual void registerAgent(DatabaseCommandHandler* databaseAgent) { ASSERT(!m_databaseAgent); m_databaseAgent = databaseAgent; }
#endif // ENABLE(SQL_DATABASE)

#if ENABLE(JAVASCRIPT_DEBUGGER)

    virtual void registerAgent(DebuggerCommandHandler* debuggerAgent) { ASSERT(!m_debuggerAgent); m_debuggerAgent = debuggerAgent; }
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

#if ENABLE(FILE_SYSTEM)

    virtual void registerAgent(FileSystemCommandHandler* fileSystemAgent) { ASSERT(!m_fileSystemAgent); m_fileSystemAgent = fileSystemAgent; }
#endif // ENABLE(FILE_SYSTEM)

#if ENABLE(INDEXED_DATABASE)

    virtual void registerAgent(IndexedDBCommandHandler* indexedDBAgent) { ASSERT(!m_indexedDBAgent); m_indexedDBAgent = indexedDBAgent; }
#endif // ENABLE(INDEXED_DATABASE)

    virtual void registerAgent(InspectorCommandHandler* inspectorAgent) { ASSERT(!m_inspectorAgent); m_inspectorAgent = inspectorAgent; }
    virtual void registerAgent(MemoryCommandHandler* memoryAgent) { ASSERT(!m_memoryAgent); m_memoryAgent = memoryAgent; }
    virtual void registerAgent(NetworkCommandHandler* networkAgent) { ASSERT(!m_networkAgent); m_networkAgent = networkAgent; }
    virtual void registerAgent(PageCommandHandler* pageAgent) { ASSERT(!m_pageAgent); m_pageAgent = pageAgent; }
#if ENABLE(JAVASCRIPT_DEBUGGER)

    virtual void registerAgent(ProfilerCommandHandler* profilerAgent) { ASSERT(!m_profilerAgent); m_profilerAgent = profilerAgent; }
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

    virtual void registerAgent(RuntimeCommandHandler* runtimeAgent) { ASSERT(!m_runtimeAgent); m_runtimeAgent = runtimeAgent; }
    virtual void registerAgent(TimelineCommandHandler* timelineAgent) { ASSERT(!m_timelineAgent); m_timelineAgent = timelineAgent; }
#if ENABLE(WORKERS)

    virtual void registerAgent(WorkerCommandHandler* workerAgent) { ASSERT(!m_workerAgent); m_workerAgent = workerAgent; }
#endif // ENABLE(WORKERS)

private:
    void Inspector_enable(long callId, InspectorObject* requestMessageObject);
    void Inspector_disable(long callId, InspectorObject* requestMessageObject);
    void Memory_getDOMNodeCount(long callId, InspectorObject* requestMessageObject);
    void Page_enable(long callId, InspectorObject* requestMessageObject);
    void Page_disable(long callId, InspectorObject* requestMessageObject);
    void Page_addScriptToEvaluateOnLoad(long callId, InspectorObject* requestMessageObject);
    void Page_removeScriptToEvaluateOnLoad(long callId, InspectorObject* requestMessageObject);
    void Page_reload(long callId, InspectorObject* requestMessageObject);
    void Page_navigate(long callId, InspectorObject* requestMessageObject);
    void Page_getCookies(long callId, InspectorObject* requestMessageObject);
    void Page_deleteCookie(long callId, InspectorObject* requestMessageObject);
    void Page_getResourceTree(long callId, InspectorObject* requestMessageObject);
    void Page_getResourceContent(long callId, InspectorObject* requestMessageObject);
    void Page_searchInResource(long callId, InspectorObject* requestMessageObject);
    void Page_searchInResources(long callId, InspectorObject* requestMessageObject);
    void Page_setDocumentContent(long callId, InspectorObject* requestMessageObject);
    void Page_setScreenSizeOverride(long callId, InspectorObject* requestMessageObject);
    void Page_setShowPaintRects(long callId, InspectorObject* requestMessageObject);
    void Runtime_evaluate(long callId, InspectorObject* requestMessageObject);
    void Runtime_callFunctionOn(long callId, InspectorObject* requestMessageObject);
    void Runtime_getProperties(long callId, InspectorObject* requestMessageObject);
    void Runtime_releaseObject(long callId, InspectorObject* requestMessageObject);
    void Runtime_releaseObjectGroup(long callId, InspectorObject* requestMessageObject);
    void Runtime_run(long callId, InspectorObject* requestMessageObject);
    void Console_enable(long callId, InspectorObject* requestMessageObject);
    void Console_disable(long callId, InspectorObject* requestMessageObject);
    void Console_clearMessages(long callId, InspectorObject* requestMessageObject);
    void Console_setMonitoringXHREnabled(long callId, InspectorObject* requestMessageObject);
    void Console_addInspectedNode(long callId, InspectorObject* requestMessageObject);
    void Console_addInspectedHeapObject(long callId, InspectorObject* requestMessageObject);
    void Network_enable(long callId, InspectorObject* requestMessageObject);
    void Network_disable(long callId, InspectorObject* requestMessageObject);
    void Network_setUserAgentOverride(long callId, InspectorObject* requestMessageObject);
    void Network_setExtraHTTPHeaders(long callId, InspectorObject* requestMessageObject);
    void Network_getResponseBody(long callId, InspectorObject* requestMessageObject);
    void Network_canClearBrowserCache(long callId, InspectorObject* requestMessageObject);
    void Network_clearBrowserCache(long callId, InspectorObject* requestMessageObject);
    void Network_canClearBrowserCookies(long callId, InspectorObject* requestMessageObject);
    void Network_clearBrowserCookies(long callId, InspectorObject* requestMessageObject);
    void Network_setCacheDisabled(long callId, InspectorObject* requestMessageObject);
#if ENABLE(SQL_DATABASE)

    void Database_enable(long callId, InspectorObject* requestMessageObject);
    void Database_disable(long callId, InspectorObject* requestMessageObject);
    void Database_getDatabaseTableNames(long callId, InspectorObject* requestMessageObject);
    void Database_executeSQL(long callId, InspectorObject* requestMessageObject);
#endif // ENABLE(SQL_DATABASE)

#if ENABLE(INDEXED_DATABASE)

    void IndexedDB_enable(long callId, InspectorObject* requestMessageObject);
    void IndexedDB_disable(long callId, InspectorObject* requestMessageObject);
    void IndexedDB_requestDatabaseNamesForFrame(long callId, InspectorObject* requestMessageObject);
    void IndexedDB_requestDatabase(long callId, InspectorObject* requestMessageObject);
    void IndexedDB_requestData(long callId, InspectorObject* requestMessageObject);
#endif // ENABLE(INDEXED_DATABASE)

    void DOMStorage_enable(long callId, InspectorObject* requestMessageObject);
    void DOMStorage_disable(long callId, InspectorObject* requestMessageObject);
    void DOMStorage_getDOMStorageEntries(long callId, InspectorObject* requestMessageObject);
    void DOMStorage_setDOMStorageItem(long callId, InspectorObject* requestMessageObject);
    void DOMStorage_removeDOMStorageItem(long callId, InspectorObject* requestMessageObject);
    void ApplicationCache_getFramesWithManifests(long callId, InspectorObject* requestMessageObject);
    void ApplicationCache_enable(long callId, InspectorObject* requestMessageObject);
    void ApplicationCache_getManifestForFrame(long callId, InspectorObject* requestMessageObject);
    void ApplicationCache_getApplicationCacheForFrame(long callId, InspectorObject* requestMessageObject);
#if ENABLE(FILE_SYSTEM)

    void FileSystem_enable(long callId, InspectorObject* requestMessageObject);
    void FileSystem_disable(long callId, InspectorObject* requestMessageObject);
#endif // ENABLE(FILE_SYSTEM)

    void DOM_getDocument(long callId, InspectorObject* requestMessageObject);
    void DOM_requestChildNodes(long callId, InspectorObject* requestMessageObject);
    void DOM_querySelector(long callId, InspectorObject* requestMessageObject);
    void DOM_querySelectorAll(long callId, InspectorObject* requestMessageObject);
    void DOM_setNodeName(long callId, InspectorObject* requestMessageObject);
    void DOM_setNodeValue(long callId, InspectorObject* requestMessageObject);
    void DOM_removeNode(long callId, InspectorObject* requestMessageObject);
    void DOM_setAttributeValue(long callId, InspectorObject* requestMessageObject);
    void DOM_setAttributesAsText(long callId, InspectorObject* requestMessageObject);
    void DOM_removeAttribute(long callId, InspectorObject* requestMessageObject);
    void DOM_getEventListenersForNode(long callId, InspectorObject* requestMessageObject);
    void DOM_getOuterHTML(long callId, InspectorObject* requestMessageObject);
    void DOM_setOuterHTML(long callId, InspectorObject* requestMessageObject);
    void DOM_performSearch(long callId, InspectorObject* requestMessageObject);
    void DOM_getSearchResults(long callId, InspectorObject* requestMessageObject);
    void DOM_discardSearchResults(long callId, InspectorObject* requestMessageObject);
    void DOM_requestNode(long callId, InspectorObject* requestMessageObject);
    void DOM_setInspectModeEnabled(long callId, InspectorObject* requestMessageObject);
    void DOM_highlightRect(long callId, InspectorObject* requestMessageObject);
    void DOM_highlightNode(long callId, InspectorObject* requestMessageObject);
    void DOM_hideHighlight(long callId, InspectorObject* requestMessageObject);
    void DOM_highlightFrame(long callId, InspectorObject* requestMessageObject);
    void DOM_pushNodeByPathToFrontend(long callId, InspectorObject* requestMessageObject);
    void DOM_resolveNode(long callId, InspectorObject* requestMessageObject);
    void DOM_getAttributes(long callId, InspectorObject* requestMessageObject);
    void DOM_moveTo(long callId, InspectorObject* requestMessageObject);
    void DOM_setTouchEmulationEnabled(long callId, InspectorObject* requestMessageObject);
    void DOM_undo(long callId, InspectorObject* requestMessageObject);
    void DOM_redo(long callId, InspectorObject* requestMessageObject);
    void DOM_markUndoableState(long callId, InspectorObject* requestMessageObject);
    void CSS_enable(long callId, InspectorObject* requestMessageObject);
    void CSS_disable(long callId, InspectorObject* requestMessageObject);
    void CSS_getMatchedStylesForNode(long callId, InspectorObject* requestMessageObject);
    void CSS_getInlineStylesForNode(long callId, InspectorObject* requestMessageObject);
    void CSS_getComputedStyleForNode(long callId, InspectorObject* requestMessageObject);
    void CSS_getAllStyleSheets(long callId, InspectorObject* requestMessageObject);
    void CSS_getStyleSheet(long callId, InspectorObject* requestMessageObject);
    void CSS_getStyleSheetText(long callId, InspectorObject* requestMessageObject);
    void CSS_setStyleSheetText(long callId, InspectorObject* requestMessageObject);
    void CSS_setPropertyText(long callId, InspectorObject* requestMessageObject);
    void CSS_toggleProperty(long callId, InspectorObject* requestMessageObject);
    void CSS_setRuleSelector(long callId, InspectorObject* requestMessageObject);
    void CSS_addRule(long callId, InspectorObject* requestMessageObject);
    void CSS_getSupportedCSSProperties(long callId, InspectorObject* requestMessageObject);
    void CSS_startSelectorProfiler(long callId, InspectorObject* requestMessageObject);
    void CSS_stopSelectorProfiler(long callId, InspectorObject* requestMessageObject);
    void Timeline_start(long callId, InspectorObject* requestMessageObject);
    void Timeline_stop(long callId, InspectorObject* requestMessageObject);
    void Timeline_setIncludeMemoryDetails(long callId, InspectorObject* requestMessageObject);
#if ENABLE(JAVASCRIPT_DEBUGGER)

    void Debugger_causesRecompilation(long callId, InspectorObject* requestMessageObject);
    void Debugger_supportsNativeBreakpoints(long callId, InspectorObject* requestMessageObject);
    void Debugger_enable(long callId, InspectorObject* requestMessageObject);
    void Debugger_disable(long callId, InspectorObject* requestMessageObject);
    void Debugger_setBreakpointsActive(long callId, InspectorObject* requestMessageObject);
    void Debugger_setBreakpointByUrl(long callId, InspectorObject* requestMessageObject);
    void Debugger_setBreakpoint(long callId, InspectorObject* requestMessageObject);
    void Debugger_removeBreakpoint(long callId, InspectorObject* requestMessageObject);
    void Debugger_continueToLocation(long callId, InspectorObject* requestMessageObject);
    void Debugger_stepOver(long callId, InspectorObject* requestMessageObject);
    void Debugger_stepInto(long callId, InspectorObject* requestMessageObject);
    void Debugger_stepOut(long callId, InspectorObject* requestMessageObject);
    void Debugger_pause(long callId, InspectorObject* requestMessageObject);
    void Debugger_resume(long callId, InspectorObject* requestMessageObject);
    void Debugger_searchInContent(long callId, InspectorObject* requestMessageObject);
    void Debugger_canSetScriptSource(long callId, InspectorObject* requestMessageObject);
    void Debugger_setScriptSource(long callId, InspectorObject* requestMessageObject);
    void Debugger_getScriptSource(long callId, InspectorObject* requestMessageObject);
    void Debugger_getFunctionDetails(long callId, InspectorObject* requestMessageObject);
    void Debugger_setPauseOnExceptions(long callId, InspectorObject* requestMessageObject);
    void Debugger_evaluateOnCallFrame(long callId, InspectorObject* requestMessageObject);
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

#if ENABLE(JAVASCRIPT_DEBUGGER)

    void DOMDebugger_setDOMBreakpoint(long callId, InspectorObject* requestMessageObject);
    void DOMDebugger_removeDOMBreakpoint(long callId, InspectorObject* requestMessageObject);
    void DOMDebugger_setEventListenerBreakpoint(long callId, InspectorObject* requestMessageObject);
    void DOMDebugger_removeEventListenerBreakpoint(long callId, InspectorObject* requestMessageObject);
    void DOMDebugger_setInstrumentationBreakpoint(long callId, InspectorObject* requestMessageObject);
    void DOMDebugger_removeInstrumentationBreakpoint(long callId, InspectorObject* requestMessageObject);
    void DOMDebugger_setXHRBreakpoint(long callId, InspectorObject* requestMessageObject);
    void DOMDebugger_removeXHRBreakpoint(long callId, InspectorObject* requestMessageObject);
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

#if ENABLE(JAVASCRIPT_DEBUGGER)

    void Profiler_causesRecompilation(long callId, InspectorObject* requestMessageObject);
    void Profiler_isSampling(long callId, InspectorObject* requestMessageObject);
    void Profiler_hasHeapProfiler(long callId, InspectorObject* requestMessageObject);
    void Profiler_enable(long callId, InspectorObject* requestMessageObject);
    void Profiler_disable(long callId, InspectorObject* requestMessageObject);
    void Profiler_start(long callId, InspectorObject* requestMessageObject);
    void Profiler_stop(long callId, InspectorObject* requestMessageObject);
    void Profiler_getProfileHeaders(long callId, InspectorObject* requestMessageObject);
    void Profiler_getProfile(long callId, InspectorObject* requestMessageObject);
    void Profiler_removeProfile(long callId, InspectorObject* requestMessageObject);
    void Profiler_clearProfiles(long callId, InspectorObject* requestMessageObject);
    void Profiler_takeHeapSnapshot(long callId, InspectorObject* requestMessageObject);
    void Profiler_collectGarbage(long callId, InspectorObject* requestMessageObject);
    void Profiler_getObjectByHeapObjectId(long callId, InspectorObject* requestMessageObject);
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

#if ENABLE(WORKERS)

    void Worker_setWorkerInspectionEnabled(long callId, InspectorObject* requestMessageObject);
    void Worker_sendMessageToWorker(long callId, InspectorObject* requestMessageObject);
    void Worker_connectToWorker(long callId, InspectorObject* requestMessageObject);
    void Worker_disconnectFromWorker(long callId, InspectorObject* requestMessageObject);
    void Worker_setAutoconnectToWorkers(long callId, InspectorObject* requestMessageObject);
#endif // ENABLE(WORKERS)


    InspectorFrontendChannel* m_inspectorFrontendChannel;
    ApplicationCacheCommandHandler* m_applicationCacheAgent;
    CSSCommandHandler* m_cssAgent;
    ConsoleCommandHandler* m_consoleAgent;
    DOMCommandHandler* m_domAgent;
#if ENABLE(JAVASCRIPT_DEBUGGER)

    DOMDebuggerCommandHandler* m_domDebuggerAgent;
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

    DOMStorageCommandHandler* m_domStorageAgent;
#if ENABLE(SQL_DATABASE)

    DatabaseCommandHandler* m_databaseAgent;
#endif // ENABLE(SQL_DATABASE)

#if ENABLE(JAVASCRIPT_DEBUGGER)

    DebuggerCommandHandler* m_debuggerAgent;
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

#if ENABLE(FILE_SYSTEM)

    FileSystemCommandHandler* m_fileSystemAgent;
#endif // ENABLE(FILE_SYSTEM)

#if ENABLE(INDEXED_DATABASE)

    IndexedDBCommandHandler* m_indexedDBAgent;
#endif // ENABLE(INDEXED_DATABASE)

    InspectorCommandHandler* m_inspectorAgent;
    MemoryCommandHandler* m_memoryAgent;
    NetworkCommandHandler* m_networkAgent;
    PageCommandHandler* m_pageAgent;
#if ENABLE(JAVASCRIPT_DEBUGGER)

    ProfilerCommandHandler* m_profilerAgent;
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

    RuntimeCommandHandler* m_runtimeAgent;
    TimelineCommandHandler* m_timelineAgent;
#if ENABLE(WORKERS)

    WorkerCommandHandler* m_workerAgent;
#endif // ENABLE(WORKERS)


    template<typename R, typename V, typename V0>
    static R getPropertyValueImpl(InspectorObject* object, const String& name, bool* valueFound, InspectorArray* protocolErrors, V0 initial_value, bool (*as_method)(InspectorValue*, V*), const char* type_name);

    static int getInt(InspectorObject* object, const String& name, bool* valueFound, InspectorArray* protocolErrors);
    static double getDouble(InspectorObject* object, const String& name, bool* valueFound, InspectorArray* protocolErrors);
    static String getString(InspectorObject* object, const String& name, bool* valueFound, InspectorArray* protocolErrors);
    static bool getBoolean(InspectorObject* object, const String& name, bool* valueFound, InspectorArray* protocolErrors);
    static PassRefPtr<InspectorObject> getObject(InspectorObject* object, const String& name, bool* valueFound, InspectorArray* protocolErrors);
    static PassRefPtr<InspectorArray> getArray(InspectorObject* object, const String& name, bool* valueFound, InspectorArray* protocolErrors);

    void sendResponse(long callId, PassRefPtr<InspectorObject> result, const String& errorMessage, PassRefPtr<InspectorArray> protocolErrors, ErrorString invocationError);

};

void InspectorBackendDispatcherImpl::Inspector_enable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_inspectorAgent)
        protocolErrors->pushString("Inspector handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_inspectorAgent->enable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Inspector.enable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Inspector_disable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_inspectorAgent)
        protocolErrors->pushString("Inspector handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_inspectorAgent->disable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Inspector.disable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Memory_getDOMNodeCount(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_memoryAgent)
        protocolErrors->pushString("Memory handler is not available.");

    RefPtr<InspectorArray> out_domGroups = InspectorArray::create();
    RefPtr<InspectorObject> out_strings = InspectorObject::create();


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_memoryAgent->getDOMNodeCount(&error, out_domGroups, out_strings);

        if (!error.length()) {
            result->setArray("domGroups", out_domGroups);
            result->setObject("strings", out_strings);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Memory.getDOMNodeCount"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Page_enable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_pageAgent->enable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Page.enable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Page_disable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_pageAgent->disable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Page.disable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Page_addScriptToEvaluateOnLoad(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    TypeBuilder::Page::ScriptIdentifier out_identifier;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_scriptSource = getString(paramsContainerPtr, "scriptSource", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_pageAgent->addScriptToEvaluateOnLoad(&error, in_scriptSource, &out_identifier);

        if (!error.length()) {
            result->setString("identifier", out_identifier);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Page.addScriptToEvaluateOnLoad"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Page_removeScriptToEvaluateOnLoad(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_identifier = getString(paramsContainerPtr, "identifier", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_pageAgent->removeScriptToEvaluateOnLoad(&error, in_identifier);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Page.removeScriptToEvaluateOnLoad"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Page_reload(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool ignoreCache_valueFound = false;
    bool in_ignoreCache = getBoolean(paramsContainerPtr, "ignoreCache", &ignoreCache_valueFound, protocolErrorsPtr);
    bool scriptToEvaluateOnLoad_valueFound = false;
    String in_scriptToEvaluateOnLoad = getString(paramsContainerPtr, "scriptToEvaluateOnLoad", &scriptToEvaluateOnLoad_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_pageAgent->reload(&error, ignoreCache_valueFound ? &in_ignoreCache : 0, scriptToEvaluateOnLoad_valueFound ? &in_scriptToEvaluateOnLoad : 0);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Page.reload"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Page_navigate(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_pageAgent->navigate(&error, in_url);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Page.navigate"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Page_getCookies(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::Page::Cookie> > out_cookies;
    String out_cookiesString;


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_pageAgent->getCookies(&error, out_cookies, &out_cookiesString);

        if (!error.length()) {
            result->setArray("cookies", out_cookies);
            result->setString("cookiesString", out_cookiesString);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Page.getCookies"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Page_deleteCookie(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_cookieName = getString(paramsContainerPtr, "cookieName", 0, protocolErrorsPtr);
    String in_domain = getString(paramsContainerPtr, "domain", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_pageAgent->deleteCookie(&error, in_cookieName, in_domain);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Page.deleteCookie"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Page_getResourceTree(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<TypeBuilder::Page::FrameResourceTree> out_frameTree;


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_pageAgent->getResourceTree(&error, out_frameTree);

        if (!error.length()) {
            result->setObject("frameTree", out_frameTree);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Page.getResourceTree"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Page_getResourceContent(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    String out_content;
    bool out_base64Encoded;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrorsPtr);
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_pageAgent->getResourceContent(&error, in_frameId, in_url, &out_content, &out_base64Encoded);

        if (!error.length()) {
            result->setString("content", out_content);
            result->setBoolean("base64Encoded", out_base64Encoded);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Page.getResourceContent"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Page_searchInResource(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::Page::SearchMatch> > out_result;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrorsPtr);
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrorsPtr);
    String in_query = getString(paramsContainerPtr, "query", 0, protocolErrorsPtr);
    bool caseSensitive_valueFound = false;
    bool in_caseSensitive = getBoolean(paramsContainerPtr, "caseSensitive", &caseSensitive_valueFound, protocolErrorsPtr);
    bool isRegex_valueFound = false;
    bool in_isRegex = getBoolean(paramsContainerPtr, "isRegex", &isRegex_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_pageAgent->searchInResource(&error, in_frameId, in_url, in_query, caseSensitive_valueFound ? &in_caseSensitive : 0, isRegex_valueFound ? &in_isRegex : 0, out_result);

        if (!error.length()) {
            result->setArray("result", out_result);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Page.searchInResource"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Page_searchInResources(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::Page::SearchResult> > out_result;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_text = getString(paramsContainerPtr, "text", 0, protocolErrorsPtr);
    bool caseSensitive_valueFound = false;
    bool in_caseSensitive = getBoolean(paramsContainerPtr, "caseSensitive", &caseSensitive_valueFound, protocolErrorsPtr);
    bool isRegex_valueFound = false;
    bool in_isRegex = getBoolean(paramsContainerPtr, "isRegex", &isRegex_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_pageAgent->searchInResources(&error, in_text, caseSensitive_valueFound ? &in_caseSensitive : 0, isRegex_valueFound ? &in_isRegex : 0, out_result);

        if (!error.length()) {
            result->setArray("result", out_result);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Page.searchInResources"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Page_setDocumentContent(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrorsPtr);
    String in_html = getString(paramsContainerPtr, "html", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_pageAgent->setDocumentContent(&error, in_frameId, in_html);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Page.setDocumentContent"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Page_setScreenSizeOverride(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_width = getInt(paramsContainerPtr, "width", 0, protocolErrorsPtr);
    int in_height = getInt(paramsContainerPtr, "height", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_pageAgent->setScreenSizeOverride(&error, in_width, in_height);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Page.setScreenSizeOverride"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Page_setShowPaintRects(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_result = getBoolean(paramsContainerPtr, "result", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_pageAgent->setShowPaintRects(&error, in_result);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Page.setShowPaintRects"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Runtime_evaluate(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;
    TypeBuilder::OptOutput<bool> out_wasThrown;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_expression = getString(paramsContainerPtr, "expression", 0, protocolErrorsPtr);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrorsPtr);
    bool includeCommandLineAPI_valueFound = false;
    bool in_includeCommandLineAPI = getBoolean(paramsContainerPtr, "includeCommandLineAPI", &includeCommandLineAPI_valueFound, protocolErrorsPtr);
    bool doNotPauseOnExceptions_valueFound = false;
    bool in_doNotPauseOnExceptions = getBoolean(paramsContainerPtr, "doNotPauseOnExceptions", &doNotPauseOnExceptions_valueFound, protocolErrorsPtr);
    bool frameId_valueFound = false;
    String in_frameId = getString(paramsContainerPtr, "frameId", &frameId_valueFound, protocolErrorsPtr);
    bool returnByValue_valueFound = false;
    bool in_returnByValue = getBoolean(paramsContainerPtr, "returnByValue", &returnByValue_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_runtimeAgent->evaluate(&error, in_expression, objectGroup_valueFound ? &in_objectGroup : 0, includeCommandLineAPI_valueFound ? &in_includeCommandLineAPI : 0, doNotPauseOnExceptions_valueFound ? &in_doNotPauseOnExceptions : 0, frameId_valueFound ? &in_frameId : 0, returnByValue_valueFound ? &in_returnByValue : 0, out_result, &out_wasThrown);

        if (!error.length()) {
            result->setObject("result", out_result);
            if (out_wasThrown.isAssigned())
                result->setBoolean("wasThrown", out_wasThrown.getValue());
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Runtime.evaluate"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Runtime_callFunctionOn(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;
    TypeBuilder::OptOutput<bool> out_wasThrown;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrorsPtr);
    String in_functionDeclaration = getString(paramsContainerPtr, "functionDeclaration", 0, protocolErrorsPtr);
    bool arguments_valueFound = false;
    RefPtr<InspectorArray> in_arguments = getArray(paramsContainerPtr, "arguments", &arguments_valueFound, protocolErrorsPtr);
    bool returnByValue_valueFound = false;
    bool in_returnByValue = getBoolean(paramsContainerPtr, "returnByValue", &returnByValue_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_runtimeAgent->callFunctionOn(&error, in_objectId, in_functionDeclaration, arguments_valueFound ? &in_arguments : 0, returnByValue_valueFound ? &in_returnByValue : 0, out_result, &out_wasThrown);

        if (!error.length()) {
            result->setObject("result", out_result);
            if (out_wasThrown.isAssigned())
                result->setBoolean("wasThrown", out_wasThrown.getValue());
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Runtime.callFunctionOn"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Runtime_getProperties(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::Runtime::PropertyDescriptor> > out_result;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrorsPtr);
    bool ownProperties_valueFound = false;
    bool in_ownProperties = getBoolean(paramsContainerPtr, "ownProperties", &ownProperties_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_runtimeAgent->getProperties(&error, in_objectId, ownProperties_valueFound ? &in_ownProperties : 0, out_result);

        if (!error.length()) {
            result->setArray("result", out_result);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Runtime.getProperties"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Runtime_releaseObject(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_runtimeAgent->releaseObject(&error, in_objectId);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Runtime.releaseObject"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Runtime_releaseObjectGroup(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_runtimeAgent->releaseObjectGroup(&error, in_objectGroup);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Runtime.releaseObjectGroup"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Runtime_run(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_runtimeAgent->run(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Runtime.run"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Console_enable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_consoleAgent->enable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Console.enable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Console_disable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_consoleAgent->disable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Console.disable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Console_clearMessages(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_consoleAgent->clearMessages(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Console.clearMessages"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Console_setMonitoringXHREnabled(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_consoleAgent->setMonitoringXHREnabled(&error, in_enabled);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Console.setMonitoringXHREnabled"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Console_addInspectedNode(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_consoleAgent->addInspectedNode(&error, in_nodeId);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Console.addInspectedNode"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Console_addInspectedHeapObject(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_heapObjectId = getInt(paramsContainerPtr, "heapObjectId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_consoleAgent->addInspectedHeapObject(&error, in_heapObjectId);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Console.addInspectedHeapObject"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Network_enable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_networkAgent->enable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Network.enable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Network_disable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_networkAgent->disable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Network.disable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Network_setUserAgentOverride(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_userAgent = getString(paramsContainerPtr, "userAgent", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_networkAgent->setUserAgentOverride(&error, in_userAgent);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Network.setUserAgentOverride"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Network_setExtraHTTPHeaders(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    RefPtr<InspectorObject> in_headers = getObject(paramsContainerPtr, "headers", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_networkAgent->setExtraHTTPHeaders(&error, in_headers);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Network.setExtraHTTPHeaders"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Network_getResponseBody(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    String out_body;
    bool out_base64Encoded;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_requestId = getString(paramsContainerPtr, "requestId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_networkAgent->getResponseBody(&error, in_requestId, &out_body, &out_base64Encoded);

        if (!error.length()) {
            result->setString("body", out_body);
            result->setBoolean("base64Encoded", out_base64Encoded);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Network.getResponseBody"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Network_canClearBrowserCache(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    bool out_result;


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_networkAgent->canClearBrowserCache(&error, &out_result);

        if (!error.length()) {
            result->setBoolean("result", out_result);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Network.canClearBrowserCache"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Network_clearBrowserCache(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_networkAgent->clearBrowserCache(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Network.clearBrowserCache"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Network_canClearBrowserCookies(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    bool out_result;


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_networkAgent->canClearBrowserCookies(&error, &out_result);

        if (!error.length()) {
            result->setBoolean("result", out_result);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Network.canClearBrowserCookies"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Network_clearBrowserCookies(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_networkAgent->clearBrowserCookies(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Network.clearBrowserCookies"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Network_setCacheDisabled(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_cacheDisabled = getBoolean(paramsContainerPtr, "cacheDisabled", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_networkAgent->setCacheDisabled(&error, in_cacheDisabled);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Network.setCacheDisabled"), protocolErrors, error);
}

#if ENABLE(SQL_DATABASE)

void InspectorBackendDispatcherImpl::Database_enable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_databaseAgent)
        protocolErrors->pushString("Database handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_databaseAgent->enable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Database.enable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Database_disable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_databaseAgent)
        protocolErrors->pushString("Database handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_databaseAgent->disable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Database.disable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Database_getDatabaseTableNames(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_databaseAgent)
        protocolErrors->pushString("Database handler is not available.");

    RefPtr<InspectorArray> out_tableNames = InspectorArray::create();


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_databaseId = getInt(paramsContainerPtr, "databaseId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_databaseAgent->getDatabaseTableNames(&error, in_databaseId, out_tableNames);

        if (!error.length()) {
            result->setArray("tableNames", out_tableNames);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Database.getDatabaseTableNames"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Database_executeSQL(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_databaseAgent)
        protocolErrors->pushString("Database handler is not available.");

    bool out_success = false;
    int out_transactionId = 0;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_databaseId = getInt(paramsContainerPtr, "databaseId", 0, protocolErrorsPtr);
    String in_query = getString(paramsContainerPtr, "query", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_databaseAgent->executeSQL(&error, in_databaseId, in_query, &out_success, &out_transactionId);

        if (!error.length()) {
            result->setBoolean("success", out_success);
            result->setNumber("transactionId", out_transactionId);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Database.executeSQL"), protocolErrors, error);
}

#endif // ENABLE(SQL_DATABASE)

#if ENABLE(INDEXED_DATABASE)

void InspectorBackendDispatcherImpl::IndexedDB_enable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_indexedDBAgent->enable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "IndexedDB.enable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::IndexedDB_disable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_indexedDBAgent->disable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "IndexedDB.disable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::IndexedDB_requestDatabaseNamesForFrame(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_requestId = getInt(paramsContainerPtr, "requestId", 0, protocolErrorsPtr);
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_indexedDBAgent->requestDatabaseNamesForFrame(&error, in_requestId, in_frameId);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "IndexedDB.requestDatabaseNamesForFrame"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::IndexedDB_requestDatabase(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_requestId = getInt(paramsContainerPtr, "requestId", 0, protocolErrorsPtr);
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrorsPtr);
    String in_databaseName = getString(paramsContainerPtr, "databaseName", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_indexedDBAgent->requestDatabase(&error, in_requestId, in_frameId, in_databaseName);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "IndexedDB.requestDatabase"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::IndexedDB_requestData(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_requestId = getInt(paramsContainerPtr, "requestId", 0, protocolErrorsPtr);
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrorsPtr);
    String in_databaseName = getString(paramsContainerPtr, "databaseName", 0, protocolErrorsPtr);
    String in_objectStoreName = getString(paramsContainerPtr, "objectStoreName", 0, protocolErrorsPtr);
    String in_indexName = getString(paramsContainerPtr, "indexName", 0, protocolErrorsPtr);
    int in_skipCount = getInt(paramsContainerPtr, "skipCount", 0, protocolErrorsPtr);
    int in_pageSize = getInt(paramsContainerPtr, "pageSize", 0, protocolErrorsPtr);
    bool keyRange_valueFound = false;
    RefPtr<InspectorObject> in_keyRange = getObject(paramsContainerPtr, "keyRange", &keyRange_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_indexedDBAgent->requestData(&error, in_requestId, in_frameId, in_databaseName, in_objectStoreName, in_indexName, in_skipCount, in_pageSize, keyRange_valueFound ? &in_keyRange : 0);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "IndexedDB.requestData"), protocolErrors, error);
}

#endif // ENABLE(INDEXED_DATABASE)

void InspectorBackendDispatcherImpl::DOMStorage_enable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domStorageAgent->enable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOMStorage.enable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOMStorage_disable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domStorageAgent->disable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOMStorage.disable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOMStorage_getDOMStorageEntries(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    RefPtr<InspectorArray> out_entries = InspectorArray::create();


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_storageId = getInt(paramsContainerPtr, "storageId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domStorageAgent->getDOMStorageEntries(&error, in_storageId, out_entries);

        if (!error.length()) {
            result->setArray("entries", out_entries);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOMStorage.getDOMStorageEntries"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOMStorage_setDOMStorageItem(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    bool out_success = false;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_storageId = getInt(paramsContainerPtr, "storageId", 0, protocolErrorsPtr);
    String in_key = getString(paramsContainerPtr, "key", 0, protocolErrorsPtr);
    String in_value = getString(paramsContainerPtr, "value", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domStorageAgent->setDOMStorageItem(&error, in_storageId, in_key, in_value, &out_success);

        if (!error.length()) {
            result->setBoolean("success", out_success);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOMStorage.setDOMStorageItem"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOMStorage_removeDOMStorageItem(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    bool out_success = false;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_storageId = getInt(paramsContainerPtr, "storageId", 0, protocolErrorsPtr);
    String in_key = getString(paramsContainerPtr, "key", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domStorageAgent->removeDOMStorageItem(&error, in_storageId, in_key, &out_success);

        if (!error.length()) {
            result->setBoolean("success", out_success);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOMStorage.removeDOMStorageItem"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::ApplicationCache_getFramesWithManifests(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_applicationCacheAgent)
        protocolErrors->pushString("ApplicationCache handler is not available.");

    RefPtr<InspectorArray> out_frameIds = InspectorArray::create();


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_applicationCacheAgent->getFramesWithManifests(&error, out_frameIds);

        if (!error.length()) {
            result->setArray("frameIds", out_frameIds);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "ApplicationCache.getFramesWithManifests"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::ApplicationCache_enable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_applicationCacheAgent)
        protocolErrors->pushString("ApplicationCache handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_applicationCacheAgent->enable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "ApplicationCache.enable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::ApplicationCache_getManifestForFrame(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_applicationCacheAgent)
        protocolErrors->pushString("ApplicationCache handler is not available.");

    String out_manifestURL = "";


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_applicationCacheAgent->getManifestForFrame(&error, in_frameId, &out_manifestURL);

        if (!error.length()) {
            result->setString("manifestURL", out_manifestURL);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "ApplicationCache.getManifestForFrame"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::ApplicationCache_getApplicationCacheForFrame(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_applicationCacheAgent)
        protocolErrors->pushString("ApplicationCache handler is not available.");

    RefPtr<InspectorObject> out_applicationCache = InspectorObject::create();


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_applicationCacheAgent->getApplicationCacheForFrame(&error, in_frameId, out_applicationCache);

        if (!error.length()) {
            result->setObject("applicationCache", out_applicationCache);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "ApplicationCache.getApplicationCacheForFrame"), protocolErrors, error);
}

#if ENABLE(FILE_SYSTEM)

void InspectorBackendDispatcherImpl::FileSystem_enable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_fileSystemAgent->enable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "FileSystem.enable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::FileSystem_disable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_fileSystemAgent->disable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "FileSystem.disable"), protocolErrors, error);
}

#endif // ENABLE(FILE_SYSTEM)

void InspectorBackendDispatcherImpl::DOM_getDocument(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<TypeBuilder::DOM::Node> out_root;


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->getDocument(&error, out_root);

        if (!error.length()) {
            result->setObject("root", out_root);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.getDocument"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_requestChildNodes(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->requestChildNodes(&error, in_nodeId);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.requestChildNodes"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_querySelector(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    int out_nodeId;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);
    String in_selector = getString(paramsContainerPtr, "selector", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->querySelector(&error, in_nodeId, in_selector, &out_nodeId);

        if (!error.length()) {
            result->setNumber("nodeId", out_nodeId);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.querySelector"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_querySelectorAll(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<TypeBuilder::Array<int> > out_nodeIds;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);
    String in_selector = getString(paramsContainerPtr, "selector", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->querySelectorAll(&error, in_nodeId, in_selector, out_nodeIds);

        if (!error.length()) {
            result->setArray("nodeIds", out_nodeIds);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.querySelectorAll"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_setNodeName(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    int out_nodeId;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);
    String in_name = getString(paramsContainerPtr, "name", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->setNodeName(&error, in_nodeId, in_name, &out_nodeId);

        if (!error.length()) {
            result->setNumber("nodeId", out_nodeId);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.setNodeName"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_setNodeValue(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);
    String in_value = getString(paramsContainerPtr, "value", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->setNodeValue(&error, in_nodeId, in_value);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.setNodeValue"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_removeNode(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->removeNode(&error, in_nodeId);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.removeNode"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_setAttributeValue(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);
    String in_name = getString(paramsContainerPtr, "name", 0, protocolErrorsPtr);
    String in_value = getString(paramsContainerPtr, "value", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->setAttributeValue(&error, in_nodeId, in_name, in_value);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.setAttributeValue"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_setAttributesAsText(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);
    String in_text = getString(paramsContainerPtr, "text", 0, protocolErrorsPtr);
    bool name_valueFound = false;
    String in_name = getString(paramsContainerPtr, "name", &name_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->setAttributesAsText(&error, in_nodeId, in_text, name_valueFound ? &in_name : 0);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.setAttributesAsText"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_removeAttribute(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);
    String in_name = getString(paramsContainerPtr, "name", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->removeAttribute(&error, in_nodeId, in_name);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.removeAttribute"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_getEventListenersForNode(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::DOM::EventListener> > out_listeners;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->getEventListenersForNode(&error, in_nodeId, out_listeners);

        if (!error.length()) {
            result->setArray("listeners", out_listeners);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.getEventListenersForNode"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_getOuterHTML(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    String out_outerHTML;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->getOuterHTML(&error, in_nodeId, &out_outerHTML);

        if (!error.length()) {
            result->setString("outerHTML", out_outerHTML);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.getOuterHTML"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_setOuterHTML(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);
    String in_outerHTML = getString(paramsContainerPtr, "outerHTML", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->setOuterHTML(&error, in_nodeId, in_outerHTML);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.setOuterHTML"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_performSearch(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    String out_searchId;
    int out_resultCount;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_query = getString(paramsContainerPtr, "query", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->performSearch(&error, in_query, &out_searchId, &out_resultCount);

        if (!error.length()) {
            result->setString("searchId", out_searchId);
            result->setNumber("resultCount", out_resultCount);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.performSearch"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_getSearchResults(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<TypeBuilder::Array<int> > out_nodeIds;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_searchId = getString(paramsContainerPtr, "searchId", 0, protocolErrorsPtr);
    int in_fromIndex = getInt(paramsContainerPtr, "fromIndex", 0, protocolErrorsPtr);
    int in_toIndex = getInt(paramsContainerPtr, "toIndex", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->getSearchResults(&error, in_searchId, in_fromIndex, in_toIndex, out_nodeIds);

        if (!error.length()) {
            result->setArray("nodeIds", out_nodeIds);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.getSearchResults"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_discardSearchResults(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_searchId = getString(paramsContainerPtr, "searchId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->discardSearchResults(&error, in_searchId);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.discardSearchResults"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_requestNode(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    int out_nodeId;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->requestNode(&error, in_objectId, &out_nodeId);

        if (!error.length()) {
            result->setNumber("nodeId", out_nodeId);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.requestNode"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_setInspectModeEnabled(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrorsPtr);
    bool highlightConfig_valueFound = false;
    RefPtr<InspectorObject> in_highlightConfig = getObject(paramsContainerPtr, "highlightConfig", &highlightConfig_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->setInspectModeEnabled(&error, in_enabled, highlightConfig_valueFound ? &in_highlightConfig : 0);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.setInspectModeEnabled"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_highlightRect(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_x = getInt(paramsContainerPtr, "x", 0, protocolErrorsPtr);
    int in_y = getInt(paramsContainerPtr, "y", 0, protocolErrorsPtr);
    int in_width = getInt(paramsContainerPtr, "width", 0, protocolErrorsPtr);
    int in_height = getInt(paramsContainerPtr, "height", 0, protocolErrorsPtr);
    bool color_valueFound = false;
    RefPtr<InspectorObject> in_color = getObject(paramsContainerPtr, "color", &color_valueFound, protocolErrorsPtr);
    bool outlineColor_valueFound = false;
    RefPtr<InspectorObject> in_outlineColor = getObject(paramsContainerPtr, "outlineColor", &outlineColor_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->highlightRect(&error, in_x, in_y, in_width, in_height, color_valueFound ? &in_color : 0, outlineColor_valueFound ? &in_outlineColor : 0);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.highlightRect"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_highlightNode(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);
    RefPtr<InspectorObject> in_highlightConfig = getObject(paramsContainerPtr, "highlightConfig", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->highlightNode(&error, in_nodeId, in_highlightConfig);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.highlightNode"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_hideHighlight(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->hideHighlight(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.hideHighlight"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_highlightFrame(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrorsPtr);
    bool contentColor_valueFound = false;
    RefPtr<InspectorObject> in_contentColor = getObject(paramsContainerPtr, "contentColor", &contentColor_valueFound, protocolErrorsPtr);
    bool contentOutlineColor_valueFound = false;
    RefPtr<InspectorObject> in_contentOutlineColor = getObject(paramsContainerPtr, "contentOutlineColor", &contentOutlineColor_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->highlightFrame(&error, in_frameId, contentColor_valueFound ? &in_contentColor : 0, contentOutlineColor_valueFound ? &in_contentOutlineColor : 0);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.highlightFrame"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_pushNodeByPathToFrontend(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    int out_nodeId;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_path = getString(paramsContainerPtr, "path", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->pushNodeByPathToFrontend(&error, in_path, &out_nodeId);

        if (!error.length()) {
            result->setNumber("nodeId", out_nodeId);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.pushNodeByPathToFrontend"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_resolveNode(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_object;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->resolveNode(&error, in_nodeId, objectGroup_valueFound ? &in_objectGroup : 0, out_object);

        if (!error.length()) {
            result->setObject("object", out_object);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.resolveNode"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_getAttributes(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<TypeBuilder::Array<String> > out_attributes;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->getAttributes(&error, in_nodeId, out_attributes);

        if (!error.length()) {
            result->setArray("attributes", out_attributes);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.getAttributes"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_moveTo(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    int out_nodeId;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);
    int in_targetNodeId = getInt(paramsContainerPtr, "targetNodeId", 0, protocolErrorsPtr);
    bool insertBeforeNodeId_valueFound = false;
    int in_insertBeforeNodeId = getInt(paramsContainerPtr, "insertBeforeNodeId", &insertBeforeNodeId_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->moveTo(&error, in_nodeId, in_targetNodeId, insertBeforeNodeId_valueFound ? &in_insertBeforeNodeId : 0, &out_nodeId);

        if (!error.length()) {
            result->setNumber("nodeId", out_nodeId);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.moveTo"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_setTouchEmulationEnabled(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->setTouchEmulationEnabled(&error, in_enabled);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.setTouchEmulationEnabled"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_undo(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->undo(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.undo"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_redo(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->redo(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.redo"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOM_markUndoableState(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domAgent->markUndoableState(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOM.markUndoableState"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::CSS_enable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_cssAgent->enable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "CSS.enable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::CSS_disable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_cssAgent->disable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "CSS.disable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::CSS_getMatchedStylesForNode(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSRule> > out_matchedCSSRules;
    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::PseudoIdRules> > out_pseudoElements;
    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::InheritedStyleEntry> > out_inherited;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);
    bool forcedPseudoClasses_valueFound = false;
    RefPtr<InspectorArray> in_forcedPseudoClasses = getArray(paramsContainerPtr, "forcedPseudoClasses", &forcedPseudoClasses_valueFound, protocolErrorsPtr);
    bool includePseudo_valueFound = false;
    bool in_includePseudo = getBoolean(paramsContainerPtr, "includePseudo", &includePseudo_valueFound, protocolErrorsPtr);
    bool includeInherited_valueFound = false;
    bool in_includeInherited = getBoolean(paramsContainerPtr, "includeInherited", &includeInherited_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_cssAgent->getMatchedStylesForNode(&error, in_nodeId, forcedPseudoClasses_valueFound ? &in_forcedPseudoClasses : 0, includePseudo_valueFound ? &in_includePseudo : 0, includeInherited_valueFound ? &in_includeInherited : 0, out_matchedCSSRules, out_pseudoElements, out_inherited);

        if (!error.length()) {
            if (out_matchedCSSRules)
                result->setArray("matchedCSSRules", out_matchedCSSRules);
            if (out_pseudoElements)
                result->setArray("pseudoElements", out_pseudoElements);
            if (out_inherited)
                result->setArray("inherited", out_inherited);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "CSS.getMatchedStylesForNode"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::CSS_getInlineStylesForNode(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<TypeBuilder::CSS::CSSStyle> out_inlineStyle;
    RefPtr<TypeBuilder::CSS::CSSStyle> out_attributesStyle;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_cssAgent->getInlineStylesForNode(&error, in_nodeId, out_inlineStyle, out_attributesStyle);

        if (!error.length()) {
            if (out_inlineStyle)
                result->setObject("inlineStyle", out_inlineStyle);
            if (out_attributesStyle)
                result->setObject("attributesStyle", out_attributesStyle);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "CSS.getInlineStylesForNode"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::CSS_getComputedStyleForNode(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSComputedStyleProperty> > out_computedStyle;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);
    bool forcedPseudoClasses_valueFound = false;
    RefPtr<InspectorArray> in_forcedPseudoClasses = getArray(paramsContainerPtr, "forcedPseudoClasses", &forcedPseudoClasses_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_cssAgent->getComputedStyleForNode(&error, in_nodeId, forcedPseudoClasses_valueFound ? &in_forcedPseudoClasses : 0, out_computedStyle);

        if (!error.length()) {
            result->setArray("computedStyle", out_computedStyle);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "CSS.getComputedStyleForNode"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::CSS_getAllStyleSheets(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSStyleSheetHeader> > out_headers;


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_cssAgent->getAllStyleSheets(&error, out_headers);

        if (!error.length()) {
            result->setArray("headers", out_headers);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "CSS.getAllStyleSheets"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::CSS_getStyleSheet(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<TypeBuilder::CSS::CSSStyleSheetBody> out_styleSheet;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_cssAgent->getStyleSheet(&error, in_styleSheetId, out_styleSheet);

        if (!error.length()) {
            result->setObject("styleSheet", out_styleSheet);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "CSS.getStyleSheet"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::CSS_getStyleSheetText(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    String out_text;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_cssAgent->getStyleSheetText(&error, in_styleSheetId, &out_text);

        if (!error.length()) {
            result->setString("text", out_text);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "CSS.getStyleSheetText"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::CSS_setStyleSheetText(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrorsPtr);
    String in_text = getString(paramsContainerPtr, "text", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_cssAgent->setStyleSheetText(&error, in_styleSheetId, in_text);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "CSS.setStyleSheetText"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::CSS_setPropertyText(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<TypeBuilder::CSS::CSSStyle> out_style;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    RefPtr<InspectorObject> in_styleId = getObject(paramsContainerPtr, "styleId", 0, protocolErrorsPtr);
    int in_propertyIndex = getInt(paramsContainerPtr, "propertyIndex", 0, protocolErrorsPtr);
    String in_text = getString(paramsContainerPtr, "text", 0, protocolErrorsPtr);
    bool in_overwrite = getBoolean(paramsContainerPtr, "overwrite", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_cssAgent->setPropertyText(&error, in_styleId, in_propertyIndex, in_text, in_overwrite, out_style);

        if (!error.length()) {
            result->setObject("style", out_style);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "CSS.setPropertyText"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::CSS_toggleProperty(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<TypeBuilder::CSS::CSSStyle> out_style;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    RefPtr<InspectorObject> in_styleId = getObject(paramsContainerPtr, "styleId", 0, protocolErrorsPtr);
    int in_propertyIndex = getInt(paramsContainerPtr, "propertyIndex", 0, protocolErrorsPtr);
    bool in_disable = getBoolean(paramsContainerPtr, "disable", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_cssAgent->toggleProperty(&error, in_styleId, in_propertyIndex, in_disable, out_style);

        if (!error.length()) {
            result->setObject("style", out_style);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "CSS.toggleProperty"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::CSS_setRuleSelector(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<TypeBuilder::CSS::CSSRule> out_rule;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    RefPtr<InspectorObject> in_ruleId = getObject(paramsContainerPtr, "ruleId", 0, protocolErrorsPtr);
    String in_selector = getString(paramsContainerPtr, "selector", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_cssAgent->setRuleSelector(&error, in_ruleId, in_selector, out_rule);

        if (!error.length()) {
            result->setObject("rule", out_rule);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "CSS.setRuleSelector"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::CSS_addRule(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<TypeBuilder::CSS::CSSRule> out_rule;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_contextNodeId = getInt(paramsContainerPtr, "contextNodeId", 0, protocolErrorsPtr);
    String in_selector = getString(paramsContainerPtr, "selector", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_cssAgent->addRule(&error, in_contextNodeId, in_selector, out_rule);

        if (!error.length()) {
            result->setObject("rule", out_rule);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "CSS.addRule"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::CSS_getSupportedCSSProperties(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<TypeBuilder::Array<String> > out_cssProperties;


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_cssAgent->getSupportedCSSProperties(&error, out_cssProperties);

        if (!error.length()) {
            result->setArray("cssProperties", out_cssProperties);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "CSS.getSupportedCSSProperties"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::CSS_startSelectorProfiler(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_cssAgent->startSelectorProfiler(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "CSS.startSelectorProfiler"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::CSS_stopSelectorProfiler(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<TypeBuilder::CSS::SelectorProfile> out_profile;


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_cssAgent->stopSelectorProfiler(&error, out_profile);

        if (!error.length()) {
            result->setObject("profile", out_profile);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "CSS.stopSelectorProfiler"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Timeline_start(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_timelineAgent)
        protocolErrors->pushString("Timeline handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool maxCallStackDepth_valueFound = false;
    int in_maxCallStackDepth = getInt(paramsContainerPtr, "maxCallStackDepth", &maxCallStackDepth_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_timelineAgent->start(&error, maxCallStackDepth_valueFound ? &in_maxCallStackDepth : 0);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Timeline.start"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Timeline_stop(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_timelineAgent)
        protocolErrors->pushString("Timeline handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_timelineAgent->stop(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Timeline.stop"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Timeline_setIncludeMemoryDetails(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_timelineAgent)
        protocolErrors->pushString("Timeline handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_timelineAgent->setIncludeMemoryDetails(&error, in_enabled);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Timeline.setIncludeMemoryDetails"), protocolErrors, error);
}

#if ENABLE(JAVASCRIPT_DEBUGGER)

void InspectorBackendDispatcherImpl::Debugger_causesRecompilation(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    bool out_result;


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->causesRecompilation(&error, &out_result);

        if (!error.length()) {
            result->setBoolean("result", out_result);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.causesRecompilation"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_supportsNativeBreakpoints(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    bool out_result;


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->supportsNativeBreakpoints(&error, &out_result);

        if (!error.length()) {
            result->setBoolean("result", out_result);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.supportsNativeBreakpoints"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_enable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->enable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.enable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_disable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->disable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.disable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_setBreakpointsActive(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_active = getBoolean(paramsContainerPtr, "active", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->setBreakpointsActive(&error, in_active);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.setBreakpointsActive"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_setBreakpointByUrl(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    TypeBuilder::Debugger::BreakpointId out_breakpointId;
    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::Location> > out_locations;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_lineNumber = getInt(paramsContainerPtr, "lineNumber", 0, protocolErrorsPtr);
    bool url_valueFound = false;
    String in_url = getString(paramsContainerPtr, "url", &url_valueFound, protocolErrorsPtr);
    bool urlRegex_valueFound = false;
    String in_urlRegex = getString(paramsContainerPtr, "urlRegex", &urlRegex_valueFound, protocolErrorsPtr);
    bool columnNumber_valueFound = false;
    int in_columnNumber = getInt(paramsContainerPtr, "columnNumber", &columnNumber_valueFound, protocolErrorsPtr);
    bool condition_valueFound = false;
    String in_condition = getString(paramsContainerPtr, "condition", &condition_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->setBreakpointByUrl(&error, in_lineNumber, url_valueFound ? &in_url : 0, urlRegex_valueFound ? &in_urlRegex : 0, columnNumber_valueFound ? &in_columnNumber : 0, condition_valueFound ? &in_condition : 0, &out_breakpointId, out_locations);

        if (!error.length()) {
            result->setString("breakpointId", out_breakpointId);
            if (out_locations)
                result->setArray("locations", out_locations);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.setBreakpointByUrl"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_setBreakpoint(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    TypeBuilder::Debugger::BreakpointId out_breakpointId;
    RefPtr<TypeBuilder::Debugger::Location> out_actualLocation;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    RefPtr<InspectorObject> in_location = getObject(paramsContainerPtr, "location", 0, protocolErrorsPtr);
    bool condition_valueFound = false;
    String in_condition = getString(paramsContainerPtr, "condition", &condition_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->setBreakpoint(&error, in_location, condition_valueFound ? &in_condition : 0, &out_breakpointId, out_actualLocation);

        if (!error.length()) {
            result->setString("breakpointId", out_breakpointId);
            result->setObject("actualLocation", out_actualLocation);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.setBreakpoint"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_removeBreakpoint(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_breakpointId = getString(paramsContainerPtr, "breakpointId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->removeBreakpoint(&error, in_breakpointId);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.removeBreakpoint"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_continueToLocation(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    RefPtr<InspectorObject> in_location = getObject(paramsContainerPtr, "location", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->continueToLocation(&error, in_location);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.continueToLocation"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_stepOver(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->stepOver(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.stepOver"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_stepInto(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->stepInto(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.stepInto"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_stepOut(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->stepOut(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.stepOut"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_pause(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->pause(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.pause"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_resume(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->resume(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.resume"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_searchInContent(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::Page::SearchMatch> > out_result;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_scriptId = getString(paramsContainerPtr, "scriptId", 0, protocolErrorsPtr);
    String in_query = getString(paramsContainerPtr, "query", 0, protocolErrorsPtr);
    bool caseSensitive_valueFound = false;
    bool in_caseSensitive = getBoolean(paramsContainerPtr, "caseSensitive", &caseSensitive_valueFound, protocolErrorsPtr);
    bool isRegex_valueFound = false;
    bool in_isRegex = getBoolean(paramsContainerPtr, "isRegex", &isRegex_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->searchInContent(&error, in_scriptId, in_query, caseSensitive_valueFound ? &in_caseSensitive : 0, isRegex_valueFound ? &in_isRegex : 0, out_result);

        if (!error.length()) {
            result->setArray("result", out_result);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.searchInContent"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_canSetScriptSource(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    bool out_result;


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->canSetScriptSource(&error, &out_result);

        if (!error.length()) {
            result->setBoolean("result", out_result);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.canSetScriptSource"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_setScriptSource(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::CallFrame> > out_callFrames;
    RefPtr<InspectorObject> out_result;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_scriptId = getString(paramsContainerPtr, "scriptId", 0, protocolErrorsPtr);
    String in_scriptSource = getString(paramsContainerPtr, "scriptSource", 0, protocolErrorsPtr);
    bool preview_valueFound = false;
    bool in_preview = getBoolean(paramsContainerPtr, "preview", &preview_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->setScriptSource(&error, in_scriptId, in_scriptSource, preview_valueFound ? &in_preview : 0, out_callFrames, out_result);

        if (!error.length()) {
            if (out_callFrames)
                result->setArray("callFrames", out_callFrames);
            if (out_result)
                result->setObject("result", out_result);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.setScriptSource"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_getScriptSource(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    String out_scriptSource;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_scriptId = getString(paramsContainerPtr, "scriptId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->getScriptSource(&error, in_scriptId, &out_scriptSource);

        if (!error.length()) {
            result->setString("scriptSource", out_scriptSource);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.getScriptSource"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_getFunctionDetails(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<TypeBuilder::Debugger::FunctionDetails> out_details;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_functionId = getString(paramsContainerPtr, "functionId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->getFunctionDetails(&error, in_functionId, out_details);

        if (!error.length()) {
            result->setObject("details", out_details);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.getFunctionDetails"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_setPauseOnExceptions(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_state = getString(paramsContainerPtr, "state", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->setPauseOnExceptions(&error, in_state);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.setPauseOnExceptions"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Debugger_evaluateOnCallFrame(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;
    TypeBuilder::OptOutput<bool> out_wasThrown;


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_callFrameId = getString(paramsContainerPtr, "callFrameId", 0, protocolErrorsPtr);
    String in_expression = getString(paramsContainerPtr, "expression", 0, protocolErrorsPtr);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrorsPtr);
    bool includeCommandLineAPI_valueFound = false;
    bool in_includeCommandLineAPI = getBoolean(paramsContainerPtr, "includeCommandLineAPI", &includeCommandLineAPI_valueFound, protocolErrorsPtr);
    bool returnByValue_valueFound = false;
    bool in_returnByValue = getBoolean(paramsContainerPtr, "returnByValue", &returnByValue_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_debuggerAgent->evaluateOnCallFrame(&error, in_callFrameId, in_expression, objectGroup_valueFound ? &in_objectGroup : 0, includeCommandLineAPI_valueFound ? &in_includeCommandLineAPI : 0, returnByValue_valueFound ? &in_returnByValue : 0, out_result, &out_wasThrown);

        if (!error.length()) {
            result->setObject("result", out_result);
            if (out_wasThrown.isAssigned())
                result->setBoolean("wasThrown", out_wasThrown.getValue());
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Debugger.evaluateOnCallFrame"), protocolErrors, error);
}

#endif // ENABLE(JAVASCRIPT_DEBUGGER)

#if ENABLE(JAVASCRIPT_DEBUGGER)

void InspectorBackendDispatcherImpl::DOMDebugger_setDOMBreakpoint(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domDebuggerAgent->setDOMBreakpoint(&error, in_nodeId, in_type);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.setDOMBreakpoint"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_removeDOMBreakpoint(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrorsPtr);
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domDebuggerAgent->removeDOMBreakpoint(&error, in_nodeId, in_type);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.removeDOMBreakpoint"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_setEventListenerBreakpoint(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_eventName = getString(paramsContainerPtr, "eventName", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domDebuggerAgent->setEventListenerBreakpoint(&error, in_eventName);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.setEventListenerBreakpoint"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_removeEventListenerBreakpoint(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_eventName = getString(paramsContainerPtr, "eventName", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domDebuggerAgent->removeEventListenerBreakpoint(&error, in_eventName);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.removeEventListenerBreakpoint"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_setInstrumentationBreakpoint(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_eventName = getString(paramsContainerPtr, "eventName", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domDebuggerAgent->setInstrumentationBreakpoint(&error, in_eventName);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.setInstrumentationBreakpoint"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_removeInstrumentationBreakpoint(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_eventName = getString(paramsContainerPtr, "eventName", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domDebuggerAgent->removeInstrumentationBreakpoint(&error, in_eventName);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.removeInstrumentationBreakpoint"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_setXHRBreakpoint(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domDebuggerAgent->setXHRBreakpoint(&error, in_url);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.setXHRBreakpoint"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_removeXHRBreakpoint(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_domDebuggerAgent->removeXHRBreakpoint(&error, in_url);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "DOMDebugger.removeXHRBreakpoint"), protocolErrors, error);
}

#endif // ENABLE(JAVASCRIPT_DEBUGGER)

#if ENABLE(JAVASCRIPT_DEBUGGER)

void InspectorBackendDispatcherImpl::Profiler_causesRecompilation(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    bool out_result = false;


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_profilerAgent->causesRecompilation(&error, &out_result);

        if (!error.length()) {
            result->setBoolean("result", out_result);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Profiler.causesRecompilation"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Profiler_isSampling(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    bool out_result = false;


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_profilerAgent->isSampling(&error, &out_result);

        if (!error.length()) {
            result->setBoolean("result", out_result);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Profiler.isSampling"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Profiler_hasHeapProfiler(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    bool out_result = false;


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_profilerAgent->hasHeapProfiler(&error, &out_result);

        if (!error.length()) {
            result->setBoolean("result", out_result);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Profiler.hasHeapProfiler"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Profiler_enable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_profilerAgent->enable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Profiler.enable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Profiler_disable(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_profilerAgent->disable(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Profiler.disable"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Profiler_start(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_profilerAgent->start(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Profiler.start"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Profiler_stop(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_profilerAgent->stop(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Profiler.stop"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Profiler_getProfileHeaders(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    RefPtr<InspectorArray> out_headers = InspectorArray::create();


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_profilerAgent->getProfileHeaders(&error, out_headers);

        if (!error.length()) {
            result->setArray("headers", out_headers);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Profiler.getProfileHeaders"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Profiler_getProfile(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    RefPtr<InspectorObject> out_profile = InspectorObject::create();


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrorsPtr);
    int in_uid = getInt(paramsContainerPtr, "uid", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_profilerAgent->getProfile(&error, in_type, in_uid, out_profile);

        if (!error.length()) {
            result->setObject("profile", out_profile);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Profiler.getProfile"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Profiler_removeProfile(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrorsPtr);
    int in_uid = getInt(paramsContainerPtr, "uid", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_profilerAgent->removeProfile(&error, in_type, in_uid);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Profiler.removeProfile"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Profiler_clearProfiles(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_profilerAgent->clearProfiles(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Profiler.clearProfiles"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Profiler_takeHeapSnapshot(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_profilerAgent->takeHeapSnapshot(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Profiler.takeHeapSnapshot"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Profiler_collectGarbage(long callId, InspectorObject*)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");


    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_profilerAgent->collectGarbage(&error);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Profiler.collectGarbage"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Profiler_getObjectByHeapObjectId(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    RefPtr<InspectorObject> out_result = InspectorObject::create();


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_objectId = getInt(paramsContainerPtr, "objectId", 0, protocolErrorsPtr);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_profilerAgent->getObjectByHeapObjectId(&error, in_objectId, objectGroup_valueFound ? &in_objectGroup : 0, out_result);

        if (!error.length()) {
            result->setObject("result", out_result);
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Profiler.getObjectByHeapObjectId"), protocolErrors, error);
}

#endif // ENABLE(JAVASCRIPT_DEBUGGER)

#if ENABLE(WORKERS)

void InspectorBackendDispatcherImpl::Worker_setWorkerInspectionEnabled(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_value = getBoolean(paramsContainerPtr, "value", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_workerAgent->setWorkerInspectionEnabled(&error, in_value);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Worker.setWorkerInspectionEnabled"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Worker_sendMessageToWorker(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_workerId = getInt(paramsContainerPtr, "workerId", 0, protocolErrorsPtr);
    RefPtr<InspectorObject> in_message = getObject(paramsContainerPtr, "message", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_workerAgent->sendMessageToWorker(&error, in_workerId, in_message);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Worker.sendMessageToWorker"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Worker_connectToWorker(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_workerId = getInt(paramsContainerPtr, "workerId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_workerAgent->connectToWorker(&error, in_workerId);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Worker.connectToWorker"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Worker_disconnectFromWorker(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_workerId = getInt(paramsContainerPtr, "workerId", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_workerAgent->disconnectFromWorker(&error, in_workerId);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Worker.disconnectFromWorker"), protocolErrors, error);
}

void InspectorBackendDispatcherImpl::Worker_setAutoconnectToWorkers(long callId, InspectorObject* requestMessageObject)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();

    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");


    RefPtr<InspectorObject> paramsContainer = requestMessageObject->getObject("params");
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    bool in_value = getBoolean(paramsContainerPtr, "value", 0, protocolErrorsPtr);

    RefPtr<InspectorObject> result = InspectorObject::create();
    ErrorString error;
    if (!protocolErrors->length()) {
        m_workerAgent->setAutoconnectToWorkers(&error, in_value);

        if (!error.length()) {
        }
    }
    sendResponse(callId, result, String::format("Some arguments of method '%s' can't be processed", "Worker.setAutoconnectToWorkers"), protocolErrors, error);
}

#endif // ENABLE(WORKERS)


PassRefPtr<InspectorBackendDispatcher> InspectorBackendDispatcher::create(InspectorFrontendChannel* inspectorFrontendChannel)
{
    return adoptRef(new InspectorBackendDispatcherImpl(inspectorFrontendChannel));
}


void InspectorBackendDispatcherImpl::dispatch(const String& message)
{
    RefPtr<InspectorBackendDispatcher> protect = this;
    typedef void (InspectorBackendDispatcherImpl::*CallHandler)(long callId, InspectorObject* messageObject);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, );
    long callId = 0;

    if (dispatchMap.isEmpty()) {
        static CallHandler handlers[] = {
            &InspectorBackendDispatcherImpl::Inspector_enable,
            &InspectorBackendDispatcherImpl::Inspector_disable,
            &InspectorBackendDispatcherImpl::Memory_getDOMNodeCount,
            &InspectorBackendDispatcherImpl::Page_enable,
            &InspectorBackendDispatcherImpl::Page_disable,
            &InspectorBackendDispatcherImpl::Page_addScriptToEvaluateOnLoad,
            &InspectorBackendDispatcherImpl::Page_removeScriptToEvaluateOnLoad,
            &InspectorBackendDispatcherImpl::Page_reload,
            &InspectorBackendDispatcherImpl::Page_navigate,
            &InspectorBackendDispatcherImpl::Page_getCookies,
            &InspectorBackendDispatcherImpl::Page_deleteCookie,
            &InspectorBackendDispatcherImpl::Page_getResourceTree,
            &InspectorBackendDispatcherImpl::Page_getResourceContent,
            &InspectorBackendDispatcherImpl::Page_searchInResource,
            &InspectorBackendDispatcherImpl::Page_searchInResources,
            &InspectorBackendDispatcherImpl::Page_setDocumentContent,
            &InspectorBackendDispatcherImpl::Page_setScreenSizeOverride,
            &InspectorBackendDispatcherImpl::Page_setShowPaintRects,
            &InspectorBackendDispatcherImpl::Runtime_evaluate,
            &InspectorBackendDispatcherImpl::Runtime_callFunctionOn,
            &InspectorBackendDispatcherImpl::Runtime_getProperties,
            &InspectorBackendDispatcherImpl::Runtime_releaseObject,
            &InspectorBackendDispatcherImpl::Runtime_releaseObjectGroup,
            &InspectorBackendDispatcherImpl::Runtime_run,
            &InspectorBackendDispatcherImpl::Console_enable,
            &InspectorBackendDispatcherImpl::Console_disable,
            &InspectorBackendDispatcherImpl::Console_clearMessages,
            &InspectorBackendDispatcherImpl::Console_setMonitoringXHREnabled,
            &InspectorBackendDispatcherImpl::Console_addInspectedNode,
            &InspectorBackendDispatcherImpl::Console_addInspectedHeapObject,
            &InspectorBackendDispatcherImpl::Network_enable,
            &InspectorBackendDispatcherImpl::Network_disable,
            &InspectorBackendDispatcherImpl::Network_setUserAgentOverride,
            &InspectorBackendDispatcherImpl::Network_setExtraHTTPHeaders,
            &InspectorBackendDispatcherImpl::Network_getResponseBody,
            &InspectorBackendDispatcherImpl::Network_canClearBrowserCache,
            &InspectorBackendDispatcherImpl::Network_clearBrowserCache,
            &InspectorBackendDispatcherImpl::Network_canClearBrowserCookies,
            &InspectorBackendDispatcherImpl::Network_clearBrowserCookies,
            &InspectorBackendDispatcherImpl::Network_setCacheDisabled,
#if ENABLE(SQL_DATABASE)

            &InspectorBackendDispatcherImpl::Database_enable,
            &InspectorBackendDispatcherImpl::Database_disable,
            &InspectorBackendDispatcherImpl::Database_getDatabaseTableNames,
            &InspectorBackendDispatcherImpl::Database_executeSQL,
#endif // ENABLE(SQL_DATABASE)

#if ENABLE(INDEXED_DATABASE)

            &InspectorBackendDispatcherImpl::IndexedDB_enable,
            &InspectorBackendDispatcherImpl::IndexedDB_disable,
            &InspectorBackendDispatcherImpl::IndexedDB_requestDatabaseNamesForFrame,
            &InspectorBackendDispatcherImpl::IndexedDB_requestDatabase,
            &InspectorBackendDispatcherImpl::IndexedDB_requestData,
#endif // ENABLE(INDEXED_DATABASE)

            &InspectorBackendDispatcherImpl::DOMStorage_enable,
            &InspectorBackendDispatcherImpl::DOMStorage_disable,
            &InspectorBackendDispatcherImpl::DOMStorage_getDOMStorageEntries,
            &InspectorBackendDispatcherImpl::DOMStorage_setDOMStorageItem,
            &InspectorBackendDispatcherImpl::DOMStorage_removeDOMStorageItem,
            &InspectorBackendDispatcherImpl::ApplicationCache_getFramesWithManifests,
            &InspectorBackendDispatcherImpl::ApplicationCache_enable,
            &InspectorBackendDispatcherImpl::ApplicationCache_getManifestForFrame,
            &InspectorBackendDispatcherImpl::ApplicationCache_getApplicationCacheForFrame,
#if ENABLE(FILE_SYSTEM)

            &InspectorBackendDispatcherImpl::FileSystem_enable,
            &InspectorBackendDispatcherImpl::FileSystem_disable,
#endif // ENABLE(FILE_SYSTEM)

            &InspectorBackendDispatcherImpl::DOM_getDocument,
            &InspectorBackendDispatcherImpl::DOM_requestChildNodes,
            &InspectorBackendDispatcherImpl::DOM_querySelector,
            &InspectorBackendDispatcherImpl::DOM_querySelectorAll,
            &InspectorBackendDispatcherImpl::DOM_setNodeName,
            &InspectorBackendDispatcherImpl::DOM_setNodeValue,
            &InspectorBackendDispatcherImpl::DOM_removeNode,
            &InspectorBackendDispatcherImpl::DOM_setAttributeValue,
            &InspectorBackendDispatcherImpl::DOM_setAttributesAsText,
            &InspectorBackendDispatcherImpl::DOM_removeAttribute,
            &InspectorBackendDispatcherImpl::DOM_getEventListenersForNode,
            &InspectorBackendDispatcherImpl::DOM_getOuterHTML,
            &InspectorBackendDispatcherImpl::DOM_setOuterHTML,
            &InspectorBackendDispatcherImpl::DOM_performSearch,
            &InspectorBackendDispatcherImpl::DOM_getSearchResults,
            &InspectorBackendDispatcherImpl::DOM_discardSearchResults,
            &InspectorBackendDispatcherImpl::DOM_requestNode,
            &InspectorBackendDispatcherImpl::DOM_setInspectModeEnabled,
            &InspectorBackendDispatcherImpl::DOM_highlightRect,
            &InspectorBackendDispatcherImpl::DOM_highlightNode,
            &InspectorBackendDispatcherImpl::DOM_hideHighlight,
            &InspectorBackendDispatcherImpl::DOM_highlightFrame,
            &InspectorBackendDispatcherImpl::DOM_pushNodeByPathToFrontend,
            &InspectorBackendDispatcherImpl::DOM_resolveNode,
            &InspectorBackendDispatcherImpl::DOM_getAttributes,
            &InspectorBackendDispatcherImpl::DOM_moveTo,
            &InspectorBackendDispatcherImpl::DOM_setTouchEmulationEnabled,
            &InspectorBackendDispatcherImpl::DOM_undo,
            &InspectorBackendDispatcherImpl::DOM_redo,
            &InspectorBackendDispatcherImpl::DOM_markUndoableState,
            &InspectorBackendDispatcherImpl::CSS_enable,
            &InspectorBackendDispatcherImpl::CSS_disable,
            &InspectorBackendDispatcherImpl::CSS_getMatchedStylesForNode,
            &InspectorBackendDispatcherImpl::CSS_getInlineStylesForNode,
            &InspectorBackendDispatcherImpl::CSS_getComputedStyleForNode,
            &InspectorBackendDispatcherImpl::CSS_getAllStyleSheets,
            &InspectorBackendDispatcherImpl::CSS_getStyleSheet,
            &InspectorBackendDispatcherImpl::CSS_getStyleSheetText,
            &InspectorBackendDispatcherImpl::CSS_setStyleSheetText,
            &InspectorBackendDispatcherImpl::CSS_setPropertyText,
            &InspectorBackendDispatcherImpl::CSS_toggleProperty,
            &InspectorBackendDispatcherImpl::CSS_setRuleSelector,
            &InspectorBackendDispatcherImpl::CSS_addRule,
            &InspectorBackendDispatcherImpl::CSS_getSupportedCSSProperties,
            &InspectorBackendDispatcherImpl::CSS_startSelectorProfiler,
            &InspectorBackendDispatcherImpl::CSS_stopSelectorProfiler,
            &InspectorBackendDispatcherImpl::Timeline_start,
            &InspectorBackendDispatcherImpl::Timeline_stop,
            &InspectorBackendDispatcherImpl::Timeline_setIncludeMemoryDetails,
#if ENABLE(JAVASCRIPT_DEBUGGER)

            &InspectorBackendDispatcherImpl::Debugger_causesRecompilation,
            &InspectorBackendDispatcherImpl::Debugger_supportsNativeBreakpoints,
            &InspectorBackendDispatcherImpl::Debugger_enable,
            &InspectorBackendDispatcherImpl::Debugger_disable,
            &InspectorBackendDispatcherImpl::Debugger_setBreakpointsActive,
            &InspectorBackendDispatcherImpl::Debugger_setBreakpointByUrl,
            &InspectorBackendDispatcherImpl::Debugger_setBreakpoint,
            &InspectorBackendDispatcherImpl::Debugger_removeBreakpoint,
            &InspectorBackendDispatcherImpl::Debugger_continueToLocation,
            &InspectorBackendDispatcherImpl::Debugger_stepOver,
            &InspectorBackendDispatcherImpl::Debugger_stepInto,
            &InspectorBackendDispatcherImpl::Debugger_stepOut,
            &InspectorBackendDispatcherImpl::Debugger_pause,
            &InspectorBackendDispatcherImpl::Debugger_resume,
            &InspectorBackendDispatcherImpl::Debugger_searchInContent,
            &InspectorBackendDispatcherImpl::Debugger_canSetScriptSource,
            &InspectorBackendDispatcherImpl::Debugger_setScriptSource,
            &InspectorBackendDispatcherImpl::Debugger_getScriptSource,
            &InspectorBackendDispatcherImpl::Debugger_getFunctionDetails,
            &InspectorBackendDispatcherImpl::Debugger_setPauseOnExceptions,
            &InspectorBackendDispatcherImpl::Debugger_evaluateOnCallFrame,
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

#if ENABLE(JAVASCRIPT_DEBUGGER)

            &InspectorBackendDispatcherImpl::DOMDebugger_setDOMBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_removeDOMBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_setEventListenerBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_removeEventListenerBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_setInstrumentationBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_removeInstrumentationBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_setXHRBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_removeXHRBreakpoint,
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

#if ENABLE(JAVASCRIPT_DEBUGGER)

            &InspectorBackendDispatcherImpl::Profiler_causesRecompilation,
            &InspectorBackendDispatcherImpl::Profiler_isSampling,
            &InspectorBackendDispatcherImpl::Profiler_hasHeapProfiler,
            &InspectorBackendDispatcherImpl::Profiler_enable,
            &InspectorBackendDispatcherImpl::Profiler_disable,
            &InspectorBackendDispatcherImpl::Profiler_start,
            &InspectorBackendDispatcherImpl::Profiler_stop,
            &InspectorBackendDispatcherImpl::Profiler_getProfileHeaders,
            &InspectorBackendDispatcherImpl::Profiler_getProfile,
            &InspectorBackendDispatcherImpl::Profiler_removeProfile,
            &InspectorBackendDispatcherImpl::Profiler_clearProfiles,
            &InspectorBackendDispatcherImpl::Profiler_takeHeapSnapshot,
            &InspectorBackendDispatcherImpl::Profiler_collectGarbage,
            &InspectorBackendDispatcherImpl::Profiler_getObjectByHeapObjectId,
#endif // ENABLE(JAVASCRIPT_DEBUGGER)

#if ENABLE(WORKERS)

            &InspectorBackendDispatcherImpl::Worker_setWorkerInspectionEnabled,
            &InspectorBackendDispatcherImpl::Worker_sendMessageToWorker,
            &InspectorBackendDispatcherImpl::Worker_connectToWorker,
            &InspectorBackendDispatcherImpl::Worker_disconnectFromWorker,
            &InspectorBackendDispatcherImpl::Worker_setAutoconnectToWorkers,
#endif // ENABLE(WORKERS)

        };
        size_t length = sizeof(commandNames) / sizeof(commandNames[0]);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commandNames[i], handlers[i]);
    }

    RefPtr<InspectorValue> parsedMessage = InspectorValue::parseJSON(message);
    if (!parsedMessage) {
        reportProtocolError(0, ParseError, "Message must be in JSON format");
        return;
    }

    RefPtr<InspectorObject> messageObject = parsedMessage->asObject();
    if (!messageObject) {
        reportProtocolError(0, InvalidRequest, "Message must be a JSONified object");
        return;
    }

    RefPtr<InspectorValue> callIdValue = messageObject->get("id");
    if (!callIdValue) {
        reportProtocolError(0, InvalidRequest, "'id' property was not found");
        return;
    }

    if (!callIdValue->asNumber(&callId)) {
        reportProtocolError(0, InvalidRequest, "The type of 'id' property must be number");
        return;
    }

    RefPtr<InspectorValue> methodValue = messageObject->get("method");
    if (!methodValue) {
        reportProtocolError(&callId, InvalidRequest, "'method' property wasn't found");
        return;
    }

    String method;
    if (!methodValue->asString(&method)) {
        reportProtocolError(&callId, InvalidRequest, "The type of 'method' property must be string");
        return;
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        reportProtocolError(&callId, MethodNotFound, "'" + method + "' wasn't found");
        return;
    }

    ((*this).*it->second)(callId, messageObject.get());
}

void InspectorBackendDispatcherImpl::sendResponse(long callId, PassRefPtr<InspectorObject> result, const String& errorMessage, PassRefPtr<InspectorArray> protocolErrors, ErrorString invocationError)
{
    if (protocolErrors->length()) {
        reportProtocolError(&callId, InvalidParams, errorMessage, protocolErrors);
        return;
    }
    if (invocationError.length()) {
        reportProtocolError(&callId, ServerError, invocationError);
        return;
    }

    RefPtr<InspectorObject> responseMessage = InspectorObject::create();
    responseMessage->setObject("result", result);
    responseMessage->setNumber("id", callId);
    if (m_inspectorFrontendChannel)
        m_inspectorFrontendChannel->sendMessageToFrontend(responseMessage->toJSONString());
}

void InspectorBackendDispatcher::reportProtocolError(const long* const callId, CommonErrorCode code, const String& errorMessage) const
{
    reportProtocolError(callId, code, errorMessage, 0);
}

void InspectorBackendDispatcherImpl::reportProtocolError(const long* const callId, CommonErrorCode code, const String& errorMessage, PassRefPtr<InspectorArray> data) const
{
    DEFINE_STATIC_LOCAL(Vector<int>,s_commonErrors,);
    if (!s_commonErrors.size()) {
        s_commonErrors.insert(ParseError, -32700);
        s_commonErrors.insert(InvalidRequest, -32600);
        s_commonErrors.insert(MethodNotFound, -32601);
        s_commonErrors.insert(InvalidParams, -32602);
        s_commonErrors.insert(InternalError, -32603);
        s_commonErrors.insert(ServerError, -32000);
    }
    ASSERT(code >=0);
    ASSERT((unsigned)code < s_commonErrors.size());
    ASSERT(s_commonErrors[code]);
    RefPtr<InspectorObject> error = InspectorObject::create();
    error->setNumber("code", s_commonErrors[code]);
    error->setString("message", errorMessage);
    ASSERT(error);
    if (data)
        error->setArray("data", data);
    RefPtr<InspectorObject> message = InspectorObject::create();
    message->setObject("error", error);
    if (callId)
        message->setNumber("id", *callId);
    else
        message->setValue("id", InspectorValue::null());
    if (m_inspectorFrontendChannel)
        m_inspectorFrontendChannel->sendMessageToFrontend(message->toJSONString());
}

template<typename R, typename V, typename V0>
R InspectorBackendDispatcherImpl::getPropertyValueImpl(InspectorObject* object, const String& name, bool* valueFound, InspectorArray* protocolErrors, V0 initial_value, bool (*as_method)(InspectorValue*, V*), const char* type_name)
{
    ASSERT(protocolErrors);

    if (valueFound)
        *valueFound = false;

    V value = initial_value;

    if (!object) {
        if (!valueFound) {
            // Required parameter in missing params container.
            protocolErrors->pushString(String::format("'params' object must contain required parameter '%s' with type '%s'.", name.utf8().data(), type_name));
        }
        return value;
    }

    InspectorObject::const_iterator end = object->end();
    InspectorObject::const_iterator valueIterator = object->find(name);

    if (valueIterator == end) {
        if (!valueFound)
            protocolErrors->pushString(String::format("Parameter '%s' with type '%s' was not found.", name.utf8().data(), type_name));
        return value;
    }

    if (!as_method(valueIterator->second.get(), &value))
        protocolErrors->pushString(String::format("Parameter '%s' has wrong type. It must be '%s'.", name.utf8().data(), type_name));
    else
        if (valueFound)
            *valueFound = true;
    return value;
}

struct AsMethodBridges {
    static bool asInt(InspectorValue* value, int* output) { return value->asNumber(output); }
    static bool asDouble(InspectorValue* value, double* output) { return value->asNumber(output); }
    static bool asString(InspectorValue* value, String* output) { return value->asString(output); }
    static bool asBoolean(InspectorValue* value, bool* output) { return value->asBoolean(output); }
    static bool asObject(InspectorValue* value, RefPtr<InspectorObject>* output) { return value->asObject(output); }
    static bool asArray(InspectorValue* value, RefPtr<InspectorArray>* output) { return value->asArray(output); }
};

int InspectorBackendDispatcherImpl::getInt(InspectorObject* object, const String& name, bool* valueFound, InspectorArray* protocolErrors)
{
    return getPropertyValueImpl<int, int, int>(object, name, valueFound, protocolErrors, 0, AsMethodBridges::asInt, "Number");
}

double InspectorBackendDispatcherImpl::getDouble(InspectorObject* object, const String& name, bool* valueFound, InspectorArray* protocolErrors)
{
    return getPropertyValueImpl<double, double, double>(object, name, valueFound, protocolErrors, 0, AsMethodBridges::asDouble, "Number");
}

String InspectorBackendDispatcherImpl::getString(InspectorObject* object, const String& name, bool* valueFound, InspectorArray* protocolErrors)
{
    return getPropertyValueImpl<String, String, String>(object, name, valueFound, protocolErrors, "", AsMethodBridges::asString, "String");
}

bool InspectorBackendDispatcherImpl::getBoolean(InspectorObject* object, const String& name, bool* valueFound, InspectorArray* protocolErrors)
{
    return getPropertyValueImpl<bool, bool, bool>(object, name, valueFound, protocolErrors, false, AsMethodBridges::asBoolean, "Boolean");
}

PassRefPtr<InspectorObject> InspectorBackendDispatcherImpl::getObject(InspectorObject* object, const String& name, bool* valueFound, InspectorArray* protocolErrors)
{
    return getPropertyValueImpl<PassRefPtr<InspectorObject>, RefPtr<InspectorObject>, InspectorObject*>(object, name, valueFound, protocolErrors, 0, AsMethodBridges::asObject, "Object");
}

PassRefPtr<InspectorArray> InspectorBackendDispatcherImpl::getArray(InspectorObject* object, const String& name, bool* valueFound, InspectorArray* protocolErrors)
{
    return getPropertyValueImpl<PassRefPtr<InspectorArray>, RefPtr<InspectorArray>, InspectorArray*>(object, name, valueFound, protocolErrors, 0, AsMethodBridges::asArray, "Array");
}

bool InspectorBackendDispatcher::getCommandName(const String& message, String* result)
{
    RefPtr<InspectorValue> value = InspectorValue::parseJSON(message);
    if (!value)
        return false;

    RefPtr<InspectorObject> object = value->asObject();
    if (!object)
        return false;

    if (!object->getString("method", result))
        return false;

    return true;
}


} // namespace WebCore

#endif // ENABLE(INSPECTOR)
