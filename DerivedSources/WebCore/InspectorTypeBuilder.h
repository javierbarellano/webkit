// File is generated by Source/WebCore/inspector/CodeGeneratorInspector.py

// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef InspectorTypeBuilder_h
#define InspectorTypeBuilder_h

#if ENABLE(INSPECTOR)

#include "InspectorValues.h"
#include <wtf/Assertions.h>
#include <wtf/PassRefPtr.h>

namespace WebCore {

namespace TypeBuilder {

template<typename T>
class OptOutput {
public:
    OptOutput() : m_assigned(false) { }

    void operator=(T value)
    {
        m_value = value;
        m_assigned = true;
    }

    bool isAssigned() { return m_assigned; }

    T getValue()
    {
        ASSERT(isAssigned());
        return m_value;
    }

private:
    T m_value;
    bool m_assigned;

    WTF_MAKE_NONCOPYABLE(OptOutput);
};


// This class provides "Traits" type for the input type T. It is programmed using C++ template specialization
// technique. By default it simply takes "ItemTraits" type from T, but it doesn't work with the base types.
template<typename T>
struct ArrayItemHelper {
    typedef typename T::ItemTraits Traits;
};

template<typename T>
class Array : public InspectorArray {
private:
    Array() { }

public:
    void addItem(PassRefPtr<T> value)
    {
        ArrayItemHelper<T>::Traits::pushRefPtr(this, value);
    }

    void addItem(T value)
    {
        ArrayItemHelper<T>::Traits::pushRaw(this, value);
    }

    static PassRefPtr<Array<T> > create()
    {
        return adoptRef(new Array<T>());
    }

    static PassRefPtr<Array<T> > runtimeCast(PassRefPtr<InspectorValue> value)
    {
        RefPtr<InspectorArray> array;
        bool castRes = value->asArray(&array);
        ASSERT_UNUSED(castRes, castRes);
#if !ASSERT_DISABLED
        assertCorrectValue(array.get());
#endif  // !ASSERT_DISABLED
        COMPILE_ASSERT(sizeof(Array<T>) == sizeof(InspectorArray), type_cast_problem);
        return static_cast<Array<T>*>(array.get());
    }

#if !ASSERT_DISABLED
    static void assertCorrectValue(InspectorValue* value)
    {
        RefPtr<InspectorArray> array;
        bool castRes = value->asArray(&array);
        ASSERT_UNUSED(castRes, castRes);
        for (unsigned i = 0; i < array->length(); i++)
            ArrayItemHelper<T>::Traits::template assertCorrectValue<T>(array->get(i).get());
    }

#endif // !ASSERT_DISABLED
};

struct StructItemTraits {
    static void pushRefPtr(InspectorArray* array, PassRefPtr<InspectorObject> value)
    {
        array->pushObject(value);
    }

    template<typename T>
    static void assertCorrectValue(InspectorValue* value) {
        T::assertCorrectValue(value);
    }
};

template<>
struct ArrayItemHelper<String> {
    struct Traits {
        static void pushRaw(InspectorArray* array, const String& value)
        {
            array->pushString(value);
        }
    };
};

template<>
struct ArrayItemHelper<int> {
    struct Traits {
        static void pushRaw(InspectorArray* array, int value)
        {
            array->pushInt(value);
        }
    };
};



template<>
struct ArrayItemHelper<InspectorObject> {
    struct Traits {
        static void pushRefPtr(InspectorArray* array, PassRefPtr<InspectorObject> value)
        {
            array->pushObject(value);
        }
    };
};

// Forward declarations.
namespace Console {
class CallFrame;
} // Console

#if ENABLE(INDEXED_DATABASE)
namespace IndexedDB {
class ObjectStore;
class ObjectStoreIndex;
} // IndexedDB

#endif // ENABLE(INDEXED_DATABASE)
namespace CSS {
class CSSRule;
class SourceRange;
class CSSStyle;
class CSSProperty;
class CSSMedia;
} // CSS

#if ENABLE(JAVASCRIPT_DEBUGGER)
namespace Debugger {
class Location;
class Scope;
} // Debugger

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
// End of forward declarations.

// Typedefs.
namespace Page {
/* Unique script identifier. */
typedef String ScriptIdentifier;

} // Page

namespace Runtime {
/* Unique object identifier. */
typedef String RemoteObjectId;

} // Runtime

namespace Network {
/* Unique loader identifier. */
typedef String LoaderId;

/* Unique frame identifier. */
typedef String FrameId;

/* Unique request identifier. */
typedef String RequestId;

} // Network

namespace CSS {
typedef String StyleSheetId;

} // CSS

#if ENABLE(JAVASCRIPT_DEBUGGER)
namespace Debugger {
/* Breakpoint identifier. */
typedef String BreakpointId;

/* Unique script identifier. */
typedef String ScriptId;

/* Call frame identifier. */
typedef String CallFrameId;

} // Debugger

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
// End of typedefs.



String getEnumConstantValue(int code);

namespace Memory {
/* Number of nodes with given name. */
class NodeCount : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        NodeNameSet = 1 << 0,
        CountSet = 1 << 1,
        AllFieldsSet = (NodeNameSet | CountSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<NodeCount> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class NodeCount;
    public:

        Builder<STATE | NodeNameSet>& setNodeName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NodeNameSet), property_nodeName_already_set);
            m_result->setString("nodeName", value);
            return castState<NodeNameSet>();
        }

        Builder<STATE | CountSet>& setCount(int value)
        {
            COMPILE_ASSERT(!(STATE & CountSet), property_count_already_set);
            m_result->setNumber("count", value);
            return castState<CountSet>();
        }

        operator RefPtr<NodeCount>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<NodeCount>*>(&m_result);
        }

        operator PassRefPtr<NodeCount> ()
        {
            return RefPtr<NodeCount>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<NodeCount> result = NodeCount::create()
     *     .setNodeName(...)
     *     .setCount(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new NodeCount()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* Number of JS event listeners by event type. */
class ListenerCount : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        CountSet = 1 << 1,
        AllFieldsSet = (TypeSet | CountSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<ListenerCount> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ListenerCount;
    public:

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type", value);
            return castState<TypeSet>();
        }

        Builder<STATE | CountSet>& setCount(int value)
        {
            COMPILE_ASSERT(!(STATE & CountSet), property_count_already_set);
            m_result->setNumber("count", value);
            return castState<CountSet>();
        }

        operator RefPtr<ListenerCount>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<ListenerCount>*>(&m_result);
        }

        operator PassRefPtr<ListenerCount> ()
        {
            return RefPtr<ListenerCount>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ListenerCount> result = ListenerCount::create()
     *     .setType(...)
     *     .setCount(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new ListenerCount()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* Character data statistics for the page. */
class StringStatistics : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        DomSet = 1 << 0,
        JsSet = 1 << 1,
        SharedSet = 1 << 2,
        AllFieldsSet = (DomSet | JsSet | SharedSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<StringStatistics> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class StringStatistics;
    public:

        Builder<STATE | DomSet>& setDom(int value)
        {
            COMPILE_ASSERT(!(STATE & DomSet), property_dom_already_set);
            m_result->setNumber("dom", value);
            return castState<DomSet>();
        }

        Builder<STATE | JsSet>& setJs(int value)
        {
            COMPILE_ASSERT(!(STATE & JsSet), property_js_already_set);
            m_result->setNumber("js", value);
            return castState<JsSet>();
        }

        Builder<STATE | SharedSet>& setShared(int value)
        {
            COMPILE_ASSERT(!(STATE & SharedSet), property_shared_already_set);
            m_result->setNumber("shared", value);
            return castState<SharedSet>();
        }

        operator RefPtr<StringStatistics>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<StringStatistics>*>(&m_result);
        }

        operator PassRefPtr<StringStatistics> ()
        {
            return RefPtr<StringStatistics>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<StringStatistics> result = StringStatistics::create()
     *     .setDom(...)
     *     .setJs(...)
     *     .setShared(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new StringStatistics()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

class DOMGroup : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        SizeSet = 1 << 0,
        TitleSet = 1 << 1,
        NodeCountSet = 1 << 2,
        ListenerCountSet = 1 << 3,
        AllFieldsSet = (SizeSet | TitleSet | NodeCountSet | ListenerCountSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<DOMGroup> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class DOMGroup;
    public:

        Builder<STATE | SizeSet>& setSize(int value)
        {
            COMPILE_ASSERT(!(STATE & SizeSet), property_size_already_set);
            m_result->setNumber("size", value);
            return castState<SizeSet>();
        }

        Builder<STATE | TitleSet>& setTitle(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TitleSet), property_title_already_set);
            m_result->setString("title", value);
            return castState<TitleSet>();
        }

        Builder<STATE | NodeCountSet>& setNodeCount(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::Memory::NodeCount> >*/ PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & NodeCountSet), property_nodeCount_already_set);
            m_result->setArray("nodeCount", value);
            return castState<NodeCountSet>();
        }

        Builder<STATE | ListenerCountSet>& setListenerCount(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::Memory::ListenerCount> >*/ PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & ListenerCountSet), property_listenerCount_already_set);
            m_result->setArray("listenerCount", value);
            return castState<ListenerCountSet>();
        }

        operator RefPtr<DOMGroup>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<DOMGroup>*>(&m_result);
        }

        operator PassRefPtr<DOMGroup> ()
        {
            return RefPtr<DOMGroup>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<DOMGroup> result = DOMGroup::create()
     *     .setSize(...)
     *     .setTitle(...)
     *     .setNodeCount(...)
     *     .setListenerCount(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new DOMGroup()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setDocumentURI(const String& value)
    {
        this->setString("documentURI", value);
    }
};

} // Memory

namespace Page {
/* Resource type as it was perceived by the rendering engine. */
struct ResourceType {
    enum Enum {
        Document = 0,
        Stylesheet = 1,
        Image = 2,
        Font = 3,
        Script = 4,
        XHR = 5,
        WebSocket = 6,
        Other = 7,
    };
}; // struct ResourceType

/* Information about the Frame on the page. */
class Frame : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        LoaderIdSet = 1 << 1,
        UrlSet = 1 << 2,
        MimeTypeSet = 1 << 3,
        AllFieldsSet = (IdSet | LoaderIdSet | UrlSet | MimeTypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Frame> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Frame;
    public:

        Builder<STATE | IdSet>& setId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & IdSet), property_id_already_set);
            m_result->setString("id", value);
            return castState<IdSet>();
        }

        Builder<STATE | LoaderIdSet>& setLoaderId(/*const TypeBuilder::Network::LoaderId&*/ const String& value)
        {
            COMPILE_ASSERT(!(STATE & LoaderIdSet), property_loaderId_already_set);
            m_result->setString("loaderId", value);
            return castState<LoaderIdSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | MimeTypeSet>& setMimeType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MimeTypeSet), property_mimeType_already_set);
            m_result->setString("mimeType", value);
            return castState<MimeTypeSet>();
        }

        operator RefPtr<Frame>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Frame>*>(&m_result);
        }

        operator PassRefPtr<Frame> ()
        {
            return RefPtr<Frame>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Frame> result = Frame::create()
     *     .setId(...)
     *     .setLoaderId(...)
     *     .setUrl(...)
     *     .setMimeType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new Frame()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setParentId(const String& value)
    {
        this->setString("parentId", value);
    }

    void setName(const String& value)
    {
        this->setString("name", value);
    }

    void setSecurityOrigin(const String& value)
    {
        this->setString("securityOrigin", value);
    }
};

/* Information about the Frame hierarchy along with their cached resources. */
class FrameResourceTree : public InspectorObject {
public:
    // Named after property name 'resources' while generating FrameResourceTree.
    class Resources : public InspectorObject {
    public:
        enum {
            NoFieldsSet = 0,
            UrlSet = 1 << 0,
            TypeSet = 1 << 1,
            MimeTypeSet = 1 << 2,
            AllFieldsSet = (UrlSet | TypeSet | MimeTypeSet)
        };

        template<int STATE>
        class Builder {
        private:
            RefPtr<InspectorObject> m_result;

            template<int STEP> Builder<STATE | STEP>& castState()
            {
                return *reinterpret_cast<Builder<STATE | STEP>*>(this);
            }

            Builder(PassRefPtr<Resources> ptr)
            {
                COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
                m_result = ptr;
            }
            friend class Resources;
        public:
    
            Builder<STATE | UrlSet>& setUrl(const String& value)
            {
                COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
                m_result->setString("url", value);
                return castState<UrlSet>();
            }
    
            Builder<STATE | TypeSet>& setType(TypeBuilder::Page::ResourceType::Enum value)
            {
                COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
                m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
                return castState<TypeSet>();
            }
    
            Builder<STATE | TypeSet>& setType(const String& value)
            {
                COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
                m_result->setString("type", value);
                return castState<TypeSet>();
            }
    
            Builder<STATE | MimeTypeSet>& setMimeType(const String& value)
            {
                COMPILE_ASSERT(!(STATE & MimeTypeSet), property_mimeType_already_set);
                m_result->setString("mimeType", value);
                return castState<MimeTypeSet>();
            }
    
            operator RefPtr<Resources>& ()
            {
                COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
                return *reinterpret_cast<RefPtr<Resources>*>(&m_result);
            }

            operator PassRefPtr<Resources> ()
            {
                return RefPtr<Resources>(*this);
            }
        };

        /*
         * Synthetic constructor:
         * RefPtr<Resources> result = Resources::create()
         *     .setUrl(...)
         *     .setType(...)
         *     .setMimeType(...);
         */
        static Builder<NoFieldsSet> create()
        {
            return Builder<NoFieldsSet>(adoptRef(new Resources()));
        }
        typedef TypeBuilder::StructItemTraits ItemTraits;

        void setFailed(bool value)
        {
            this->setBoolean("failed", value);
        }

        void setCanceled(bool value)
        {
            this->setBoolean("canceled", value);
        }
    };

    enum {
        NoFieldsSet = 0,
        FrameSet = 1 << 0,
        ResourcesSet = 1 << 1,
        AllFieldsSet = (FrameSet | ResourcesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<FrameResourceTree> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class FrameResourceTree;
    public:

        Builder<STATE | FrameSet>& setFrame(/*PassRefPtr<TypeBuilder::Page::Frame>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & FrameSet), property_frame_already_set);
            m_result->setObject("frame", value);
            return castState<FrameSet>();
        }

        Builder<STATE | ResourcesSet>& setResources(/*PassRefPtr<TypeBuilder::Array<<not yet defined>Resources> >*/ PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & ResourcesSet), property_resources_already_set);
            m_result->setArray("resources", value);
            return castState<ResourcesSet>();
        }

        operator RefPtr<FrameResourceTree>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<FrameResourceTree>*>(&m_result);
        }

        operator PassRefPtr<FrameResourceTree> ()
        {
            return RefPtr<FrameResourceTree>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<FrameResourceTree> result = FrameResourceTree::create()
     *     .setFrame(...)
     *     .setResources(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new FrameResourceTree()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setChildFrames(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::Page::FrameResourceTree> >*/ PassRefPtr<InspectorArray> value)
    {
        this->setArray("childFrames", value);
    }
};

/* Search match for resource. */
class SearchMatch : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        LineNumberSet = 1 << 0,
        LineContentSet = 1 << 1,
        AllFieldsSet = (LineNumberSet | LineContentSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<SearchMatch> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class SearchMatch;
    public:

        Builder<STATE | LineNumberSet>& setLineNumber(double value)
        {
            COMPILE_ASSERT(!(STATE & LineNumberSet), property_lineNumber_already_set);
            m_result->setNumber("lineNumber", value);
            return castState<LineNumberSet>();
        }

        Builder<STATE | LineContentSet>& setLineContent(const String& value)
        {
            COMPILE_ASSERT(!(STATE & LineContentSet), property_lineContent_already_set);
            m_result->setString("lineContent", value);
            return castState<LineContentSet>();
        }

        operator RefPtr<SearchMatch>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<SearchMatch>*>(&m_result);
        }

        operator PassRefPtr<SearchMatch> ()
        {
            return RefPtr<SearchMatch>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SearchMatch> result = SearchMatch::create()
     *     .setLineNumber(...)
     *     .setLineContent(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new SearchMatch()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* Search result for resource. */
class SearchResult : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        FrameIdSet = 1 << 1,
        MatchesCountSet = 1 << 2,
        AllFieldsSet = (UrlSet | FrameIdSet | MatchesCountSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<SearchResult> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class SearchResult;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | FrameIdSet>& setFrameId(/*const TypeBuilder::Network::FrameId&*/ const String& value)
        {
            COMPILE_ASSERT(!(STATE & FrameIdSet), property_frameId_already_set);
            m_result->setString("frameId", value);
            return castState<FrameIdSet>();
        }

        Builder<STATE | MatchesCountSet>& setMatchesCount(double value)
        {
            COMPILE_ASSERT(!(STATE & MatchesCountSet), property_matchesCount_already_set);
            m_result->setNumber("matchesCount", value);
            return castState<MatchesCountSet>();
        }

        operator RefPtr<SearchResult>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<SearchResult>*>(&m_result);
        }

        operator PassRefPtr<SearchResult> ()
        {
            return RefPtr<SearchResult>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SearchResult> result = SearchResult::create()
     *     .setUrl(...)
     *     .setFrameId(...)
     *     .setMatchesCount(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new SearchResult()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* Cookie object */
class Cookie : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        DomainSet = 1 << 2,
        PathSet = 1 << 3,
        ExpiresSet = 1 << 4,
        SizeSet = 1 << 5,
        HttpOnlySet = 1 << 6,
        SecureSet = 1 << 7,
        SessionSet = 1 << 8,
        AllFieldsSet = (NameSet | ValueSet | DomainSet | PathSet | ExpiresSet | SizeSet | HttpOnlySet | SecureSet | SessionSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Cookie> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Cookie;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString("value", value);
            return castState<ValueSet>();
        }

        Builder<STATE | DomainSet>& setDomain(const String& value)
        {
            COMPILE_ASSERT(!(STATE & DomainSet), property_domain_already_set);
            m_result->setString("domain", value);
            return castState<DomainSet>();
        }

        Builder<STATE | PathSet>& setPath(const String& value)
        {
            COMPILE_ASSERT(!(STATE & PathSet), property_path_already_set);
            m_result->setString("path", value);
            return castState<PathSet>();
        }

        Builder<STATE | ExpiresSet>& setExpires(int value)
        {
            COMPILE_ASSERT(!(STATE & ExpiresSet), property_expires_already_set);
            m_result->setNumber("expires", value);
            return castState<ExpiresSet>();
        }

        Builder<STATE | SizeSet>& setSize(int value)
        {
            COMPILE_ASSERT(!(STATE & SizeSet), property_size_already_set);
            m_result->setNumber("size", value);
            return castState<SizeSet>();
        }

        Builder<STATE | HttpOnlySet>& setHttpOnly(bool value)
        {
            COMPILE_ASSERT(!(STATE & HttpOnlySet), property_httpOnly_already_set);
            m_result->setBoolean("httpOnly", value);
            return castState<HttpOnlySet>();
        }

        Builder<STATE | SecureSet>& setSecure(bool value)
        {
            COMPILE_ASSERT(!(STATE & SecureSet), property_secure_already_set);
            m_result->setBoolean("secure", value);
            return castState<SecureSet>();
        }

        Builder<STATE | SessionSet>& setSession(bool value)
        {
            COMPILE_ASSERT(!(STATE & SessionSet), property_session_already_set);
            m_result->setBoolean("session", value);
            return castState<SessionSet>();
        }

        operator RefPtr<Cookie>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Cookie>*>(&m_result);
        }

        operator PassRefPtr<Cookie> ()
        {
            return RefPtr<Cookie>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Cookie> result = Cookie::create()
     *     .setName(...)
     *     .setValue(...)
     *     .setDomain(...)
     *     .setPath(...)
     *     .setExpires(...)
     *     .setSize(...)
     *     .setHttpOnly(...)
     *     .setSecure(...)
     *     .setSession(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new Cookie()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

} // Page

namespace Runtime {
/* Mirror object referencing original JavaScript object. */
class RemoteObject : public InspectorObject {
public:
    // Named after property name 'type' while generating RemoteObject.
    struct Type {
        enum Enum {
            Object = 8,
            Function = 9,
            Undefined = 10,
            String = 11,
            Number = 12,
            Boolean = 13,
        };
#if !ASSERT_DISABLED
        static void assertCorrectValue(InspectorValue* value);
#endif  // !ASSERT_DISABLED
    }; // struct Type

    // Named after property name 'subtype' while generating RemoteObject.
    struct Subtype {
        enum Enum {
            Array = 14,
            Null = 15,
            Node = 16,
            Regexp = 17,
            Date = 18,
        };
#if !ASSERT_DISABLED
        static void assertCorrectValue(InspectorValue* value);
#endif  // !ASSERT_DISABLED
    }; // struct Subtype

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<RemoteObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class RemoteObject;
    public:

        Builder<STATE | TypeSet>& setType(Type::Enum value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type", value);
            return castState<TypeSet>();
        }

        operator RefPtr<RemoteObject>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<RemoteObject>*>(&m_result);
        }

        operator PassRefPtr<RemoteObject> ()
        {
            return RefPtr<RemoteObject>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<RemoteObject> result = RemoteObject::create()
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new RemoteObject()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setSubtype(Subtype::Enum value)
    {
        this->setString("subtype", TypeBuilder::getEnumConstantValue(value));
    }

    void setSubtype(const String& value)
    {
        this->setString("subtype", value);
    }

    void setClassName(const String& value)
    {
        this->setString("className", value);
    }

    void setValue(PassRefPtr<InspectorValue> value)
    {
        this->setValue("value", value);
    }
    using InspectorObject::setValue;


    void setDescription(const String& value)
    {
        this->setString("description", value);
    }

    void setObjectId(/*const TypeBuilder::Runtime::RemoteObjectId&*/ const String& value)
    {
        this->setString("objectId", value);
    }
    static PassRefPtr<RemoteObject> runtimeCast(PassRefPtr<InspectorValue> value)
    {
        RefPtr<InspectorObject> object;
        bool castRes = value->asObject(&object);
        ASSERT_UNUSED(castRes, castRes);
#if !ASSERT_DISABLED
        assertCorrectValue(object.get());
#endif  // !ASSERT_DISABLED
        COMPILE_ASSERT(sizeof(RemoteObject) == sizeof(InspectorObject), type_cast_problem);
        return static_cast<RemoteObject*>(object.get());
    }

#if !ASSERT_DISABLED
    static void assertCorrectValue(InspectorValue* value);
#endif  // !ASSERT_DISABLED
};

/* Object property descriptor. */
class PropertyDescriptor : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ConfigurableSet = 1 << 1,
        EnumerableSet = 1 << 2,
        AllFieldsSet = (NameSet | ConfigurableSet | EnumerableSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<PropertyDescriptor> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class PropertyDescriptor;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | ConfigurableSet>& setConfigurable(bool value)
        {
            COMPILE_ASSERT(!(STATE & ConfigurableSet), property_configurable_already_set);
            m_result->setBoolean("configurable", value);
            return castState<ConfigurableSet>();
        }

        Builder<STATE | EnumerableSet>& setEnumerable(bool value)
        {
            COMPILE_ASSERT(!(STATE & EnumerableSet), property_enumerable_already_set);
            m_result->setBoolean("enumerable", value);
            return castState<EnumerableSet>();
        }

        operator RefPtr<PropertyDescriptor>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<PropertyDescriptor>*>(&m_result);
        }

        operator PassRefPtr<PropertyDescriptor> ()
        {
            return RefPtr<PropertyDescriptor>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<PropertyDescriptor> result = PropertyDescriptor::create()
     *     .setName(...)
     *     .setConfigurable(...)
     *     .setEnumerable(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new PropertyDescriptor()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setValue(/*PassRefPtr<TypeBuilder::Runtime::RemoteObject>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("value", value);
    }
    using InspectorObject::setValue;


    void setWritable(bool value)
    {
        this->setBoolean("writable", value);
    }

    void setGet(/*PassRefPtr<TypeBuilder::Runtime::RemoteObject>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("get", value);
    }

    void setSet(/*PassRefPtr<TypeBuilder::Runtime::RemoteObject>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("set", value);
    }

    void setWasThrown(bool value)
    {
        this->setBoolean("wasThrown", value);
    }
    static PassRefPtr<PropertyDescriptor> runtimeCast(PassRefPtr<InspectorValue> value)
    {
        RefPtr<InspectorObject> object;
        bool castRes = value->asObject(&object);
        ASSERT_UNUSED(castRes, castRes);
#if !ASSERT_DISABLED
        assertCorrectValue(object.get());
#endif  // !ASSERT_DISABLED
        COMPILE_ASSERT(sizeof(PropertyDescriptor) == sizeof(InspectorObject), type_cast_problem);
        return static_cast<PropertyDescriptor*>(object.get());
    }

#if !ASSERT_DISABLED
    static void assertCorrectValue(InspectorValue* value);
#endif  // !ASSERT_DISABLED
};

/* Represents function call argument. Either remote object id <code>objectId</code> or primitive <code>value</code> or neither of (for undefined) them should be specified. */
class CallArgument : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CallArgument> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CallArgument;
    public:

        operator RefPtr<CallArgument>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CallArgument>*>(&m_result);
        }

        operator PassRefPtr<CallArgument> ()
        {
            return RefPtr<CallArgument>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CallArgument> result = CallArgument::create();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new CallArgument()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setValue(PassRefPtr<InspectorValue> value)
    {
        this->setValue("value", value);
    }
    using InspectorObject::setValue;


    void setObjectId(/*const TypeBuilder::Runtime::RemoteObjectId&*/ const String& value)
    {
        this->setString("objectId", value);
    }
};

} // Runtime

namespace Console {
/* Console message. */
class ConsoleMessage : public InspectorObject {
public:
    // Named after property name 'source' while generating ConsoleMessage.
    struct Source {
        enum Enum {
            Html = 19,
            Wml = 20,
            Xml = 21,
            Javascript = 22,
            Network = 23,
            Console_api = 24,
            Other = 25,
        };
    }; // struct Source

    // Named after property name 'level' while generating ConsoleMessage.
    struct Level {
        enum Enum {
            Tip = 26,
            Log = 27,
            Warning = 28,
            Error = 29,
            Debug = 30,
        };
    }; // struct Level

    // Named after property name 'type' while generating ConsoleMessage.
    struct Type {
        enum Enum {
            Log = 27,
            Dir = 31,
            Dirxml = 32,
            Trace = 33,
            StartGroup = 34,
            StartGroupCollapsed = 35,
            EndGroup = 36,
            Assert = 37,
        };
    }; // struct Type

    enum {
        NoFieldsSet = 0,
        SourceSet = 1 << 0,
        LevelSet = 1 << 1,
        TextSet = 1 << 2,
        AllFieldsSet = (SourceSet | LevelSet | TextSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<ConsoleMessage> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ConsoleMessage;
    public:

        Builder<STATE | SourceSet>& setSource(Source::Enum value)
        {
            COMPILE_ASSERT(!(STATE & SourceSet), property_source_already_set);
            m_result->setString("source", TypeBuilder::getEnumConstantValue(value));
            return castState<SourceSet>();
        }

        Builder<STATE | SourceSet>& setSource(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SourceSet), property_source_already_set);
            m_result->setString("source", value);
            return castState<SourceSet>();
        }

        Builder<STATE | LevelSet>& setLevel(Level::Enum value)
        {
            COMPILE_ASSERT(!(STATE & LevelSet), property_level_already_set);
            m_result->setString("level", TypeBuilder::getEnumConstantValue(value));
            return castState<LevelSet>();
        }

        Builder<STATE | LevelSet>& setLevel(const String& value)
        {
            COMPILE_ASSERT(!(STATE & LevelSet), property_level_already_set);
            m_result->setString("level", value);
            return castState<LevelSet>();
        }

        Builder<STATE | TextSet>& setText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TextSet), property_text_already_set);
            m_result->setString("text", value);
            return castState<TextSet>();
        }

        operator RefPtr<ConsoleMessage>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<ConsoleMessage>*>(&m_result);
        }

        operator PassRefPtr<ConsoleMessage> ()
        {
            return RefPtr<ConsoleMessage>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ConsoleMessage> result = ConsoleMessage::create()
     *     .setSource(...)
     *     .setLevel(...)
     *     .setText(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new ConsoleMessage()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setType(Type::Enum value)
    {
        this->setString("type", TypeBuilder::getEnumConstantValue(value));
    }

    void setType(const String& value)
    {
        this->setString("type", value);
    }

    void setUrl(const String& value)
    {
        this->setString("url", value);
    }

    void setLine(int value)
    {
        this->setNumber("line", value);
    }

    void setRepeatCount(int value)
    {
        this->setNumber("repeatCount", value);
    }

    void setParameters(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::Runtime::RemoteObject> >*/ PassRefPtr<InspectorArray> value)
    {
        this->setArray("parameters", value);
    }

    void setStackTrace(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::Console::CallFrame> >*/ PassRefPtr<InspectorArray> value)
    {
        this->setArray("stackTrace", value);
    }

    void setNetworkRequestId(/*const TypeBuilder::Network::RequestId&*/ const String& value)
    {
        this->setString("networkRequestId", value);
    }
};

/* Stack entry for console errors and assertions. */
class CallFrame : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        FunctionNameSet = 1 << 0,
        UrlSet = 1 << 1,
        LineNumberSet = 1 << 2,
        ColumnNumberSet = 1 << 3,
        AllFieldsSet = (FunctionNameSet | UrlSet | LineNumberSet | ColumnNumberSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CallFrame> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CallFrame;
    public:

        Builder<STATE | FunctionNameSet>& setFunctionName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & FunctionNameSet), property_functionName_already_set);
            m_result->setString("functionName", value);
            return castState<FunctionNameSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | LineNumberSet>& setLineNumber(int value)
        {
            COMPILE_ASSERT(!(STATE & LineNumberSet), property_lineNumber_already_set);
            m_result->setNumber("lineNumber", value);
            return castState<LineNumberSet>();
        }

        Builder<STATE | ColumnNumberSet>& setColumnNumber(int value)
        {
            COMPILE_ASSERT(!(STATE & ColumnNumberSet), property_columnNumber_already_set);
            m_result->setNumber("columnNumber", value);
            return castState<ColumnNumberSet>();
        }

        operator RefPtr<CallFrame>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CallFrame>*>(&m_result);
        }

        operator PassRefPtr<CallFrame> ()
        {
            return RefPtr<CallFrame>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CallFrame> result = CallFrame::create()
     *     .setFunctionName(...)
     *     .setUrl(...)
     *     .setLineNumber(...)
     *     .setColumnNumber(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new CallFrame()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

} // Console

namespace Network {
/* Timing information for the request. */
class ResourceTiming : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        RequestTimeSet = 1 << 0,
        ProxyStartSet = 1 << 1,
        ProxyEndSet = 1 << 2,
        DnsStartSet = 1 << 3,
        DnsEndSet = 1 << 4,
        ConnectStartSet = 1 << 5,
        ConnectEndSet = 1 << 6,
        SslStartSet = 1 << 7,
        SslEndSet = 1 << 8,
        SendStartSet = 1 << 9,
        SendEndSet = 1 << 10,
        ReceiveHeadersEndSet = 1 << 11,
        AllFieldsSet = (RequestTimeSet | ProxyStartSet | ProxyEndSet | DnsStartSet | DnsEndSet | ConnectStartSet | ConnectEndSet | SslStartSet | SslEndSet | SendStartSet | SendEndSet | ReceiveHeadersEndSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<ResourceTiming> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ResourceTiming;
    public:

        Builder<STATE | RequestTimeSet>& setRequestTime(double value)
        {
            COMPILE_ASSERT(!(STATE & RequestTimeSet), property_requestTime_already_set);
            m_result->setNumber("requestTime", value);
            return castState<RequestTimeSet>();
        }

        Builder<STATE | ProxyStartSet>& setProxyStart(double value)
        {
            COMPILE_ASSERT(!(STATE & ProxyStartSet), property_proxyStart_already_set);
            m_result->setNumber("proxyStart", value);
            return castState<ProxyStartSet>();
        }

        Builder<STATE | ProxyEndSet>& setProxyEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & ProxyEndSet), property_proxyEnd_already_set);
            m_result->setNumber("proxyEnd", value);
            return castState<ProxyEndSet>();
        }

        Builder<STATE | DnsStartSet>& setDnsStart(double value)
        {
            COMPILE_ASSERT(!(STATE & DnsStartSet), property_dnsStart_already_set);
            m_result->setNumber("dnsStart", value);
            return castState<DnsStartSet>();
        }

        Builder<STATE | DnsEndSet>& setDnsEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & DnsEndSet), property_dnsEnd_already_set);
            m_result->setNumber("dnsEnd", value);
            return castState<DnsEndSet>();
        }

        Builder<STATE | ConnectStartSet>& setConnectStart(double value)
        {
            COMPILE_ASSERT(!(STATE & ConnectStartSet), property_connectStart_already_set);
            m_result->setNumber("connectStart", value);
            return castState<ConnectStartSet>();
        }

        Builder<STATE | ConnectEndSet>& setConnectEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & ConnectEndSet), property_connectEnd_already_set);
            m_result->setNumber("connectEnd", value);
            return castState<ConnectEndSet>();
        }

        Builder<STATE | SslStartSet>& setSslStart(double value)
        {
            COMPILE_ASSERT(!(STATE & SslStartSet), property_sslStart_already_set);
            m_result->setNumber("sslStart", value);
            return castState<SslStartSet>();
        }

        Builder<STATE | SslEndSet>& setSslEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & SslEndSet), property_sslEnd_already_set);
            m_result->setNumber("sslEnd", value);
            return castState<SslEndSet>();
        }

        Builder<STATE | SendStartSet>& setSendStart(double value)
        {
            COMPILE_ASSERT(!(STATE & SendStartSet), property_sendStart_already_set);
            m_result->setNumber("sendStart", value);
            return castState<SendStartSet>();
        }

        Builder<STATE | SendEndSet>& setSendEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & SendEndSet), property_sendEnd_already_set);
            m_result->setNumber("sendEnd", value);
            return castState<SendEndSet>();
        }

        Builder<STATE | ReceiveHeadersEndSet>& setReceiveHeadersEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & ReceiveHeadersEndSet), property_receiveHeadersEnd_already_set);
            m_result->setNumber("receiveHeadersEnd", value);
            return castState<ReceiveHeadersEndSet>();
        }

        operator RefPtr<ResourceTiming>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<ResourceTiming>*>(&m_result);
        }

        operator PassRefPtr<ResourceTiming> ()
        {
            return RefPtr<ResourceTiming>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ResourceTiming> result = ResourceTiming::create()
     *     .setRequestTime(...)
     *     .setProxyStart(...)
     *     .setProxyEnd(...)
     *     .setDnsStart(...)
     *     .setDnsEnd(...)
     *     .setConnectStart(...)
     *     .setConnectEnd(...)
     *     .setSslStart(...)
     *     .setSslEnd(...)
     *     .setSendStart(...)
     *     .setSendEnd(...)
     *     .setReceiveHeadersEnd(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new ResourceTiming()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* HTTP request data. */
class Request : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        MethodSet = 1 << 1,
        HeadersSet = 1 << 2,
        AllFieldsSet = (UrlSet | MethodSet | HeadersSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Request> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Request;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | MethodSet>& setMethod(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MethodSet), property_method_already_set);
            m_result->setString("method", value);
            return castState<MethodSet>();
        }

        Builder<STATE | HeadersSet>& setHeaders(PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & HeadersSet), property_headers_already_set);
            m_result->setObject("headers", value);
            return castState<HeadersSet>();
        }

        operator RefPtr<Request>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Request>*>(&m_result);
        }

        operator PassRefPtr<Request> ()
        {
            return RefPtr<Request>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Request> result = Request::create()
     *     .setUrl(...)
     *     .setMethod(...)
     *     .setHeaders(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new Request()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setPostData(const String& value)
    {
        this->setString("postData", value);
    }
};

/* HTTP response data. */
class Response : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        StatusSet = 1 << 1,
        StatusTextSet = 1 << 2,
        HeadersSet = 1 << 3,
        MimeTypeSet = 1 << 4,
        ConnectionReusedSet = 1 << 5,
        ConnectionIdSet = 1 << 6,
        AllFieldsSet = (UrlSet | StatusSet | StatusTextSet | HeadersSet | MimeTypeSet | ConnectionReusedSet | ConnectionIdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Response> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Response;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | StatusSet>& setStatus(double value)
        {
            COMPILE_ASSERT(!(STATE & StatusSet), property_status_already_set);
            m_result->setNumber("status", value);
            return castState<StatusSet>();
        }

        Builder<STATE | StatusTextSet>& setStatusText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & StatusTextSet), property_statusText_already_set);
            m_result->setString("statusText", value);
            return castState<StatusTextSet>();
        }

        Builder<STATE | HeadersSet>& setHeaders(PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & HeadersSet), property_headers_already_set);
            m_result->setObject("headers", value);
            return castState<HeadersSet>();
        }

        Builder<STATE | MimeTypeSet>& setMimeType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MimeTypeSet), property_mimeType_already_set);
            m_result->setString("mimeType", value);
            return castState<MimeTypeSet>();
        }

        Builder<STATE | ConnectionReusedSet>& setConnectionReused(bool value)
        {
            COMPILE_ASSERT(!(STATE & ConnectionReusedSet), property_connectionReused_already_set);
            m_result->setBoolean("connectionReused", value);
            return castState<ConnectionReusedSet>();
        }

        Builder<STATE | ConnectionIdSet>& setConnectionId(double value)
        {
            COMPILE_ASSERT(!(STATE & ConnectionIdSet), property_connectionId_already_set);
            m_result->setNumber("connectionId", value);
            return castState<ConnectionIdSet>();
        }

        operator RefPtr<Response>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Response>*>(&m_result);
        }

        operator PassRefPtr<Response> ()
        {
            return RefPtr<Response>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Response> result = Response::create()
     *     .setUrl(...)
     *     .setStatus(...)
     *     .setStatusText(...)
     *     .setHeaders(...)
     *     .setMimeType(...)
     *     .setConnectionReused(...)
     *     .setConnectionId(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new Response()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setHeadersText(const String& value)
    {
        this->setString("headersText", value);
    }

    void setRequestHeaders(PassRefPtr<InspectorObject> value)
    {
        this->setObject("requestHeaders", value);
    }

    void setRequestHeadersText(const String& value)
    {
        this->setString("requestHeadersText", value);
    }

    void setFromDiskCache(bool value)
    {
        this->setBoolean("fromDiskCache", value);
    }

    void setTiming(/*PassRefPtr<TypeBuilder::Network::ResourceTiming>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("timing", value);
    }
};

/* WebSocket request data. */
class WebSocketRequest : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        RequestKey3Set = 1 << 0,
        HeadersSet = 1 << 1,
        AllFieldsSet = (RequestKey3Set | HeadersSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<WebSocketRequest> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class WebSocketRequest;
    public:

        Builder<STATE | RequestKey3Set>& setRequestKey3(const String& value)
        {
            COMPILE_ASSERT(!(STATE & RequestKey3Set), property_requestKey3_already_set);
            m_result->setString("requestKey3", value);
            return castState<RequestKey3Set>();
        }

        Builder<STATE | HeadersSet>& setHeaders(PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & HeadersSet), property_headers_already_set);
            m_result->setObject("headers", value);
            return castState<HeadersSet>();
        }

        operator RefPtr<WebSocketRequest>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<WebSocketRequest>*>(&m_result);
        }

        operator PassRefPtr<WebSocketRequest> ()
        {
            return RefPtr<WebSocketRequest>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<WebSocketRequest> result = WebSocketRequest::create()
     *     .setRequestKey3(...)
     *     .setHeaders(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new WebSocketRequest()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* WebSocket response data. */
class WebSocketResponse : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        StatusSet = 1 << 0,
        StatusTextSet = 1 << 1,
        HeadersSet = 1 << 2,
        ChallengeResponseSet = 1 << 3,
        AllFieldsSet = (StatusSet | StatusTextSet | HeadersSet | ChallengeResponseSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<WebSocketResponse> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class WebSocketResponse;
    public:

        Builder<STATE | StatusSet>& setStatus(double value)
        {
            COMPILE_ASSERT(!(STATE & StatusSet), property_status_already_set);
            m_result->setNumber("status", value);
            return castState<StatusSet>();
        }

        Builder<STATE | StatusTextSet>& setStatusText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & StatusTextSet), property_statusText_already_set);
            m_result->setString("statusText", value);
            return castState<StatusTextSet>();
        }

        Builder<STATE | HeadersSet>& setHeaders(PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & HeadersSet), property_headers_already_set);
            m_result->setObject("headers", value);
            return castState<HeadersSet>();
        }

        Builder<STATE | ChallengeResponseSet>& setChallengeResponse(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ChallengeResponseSet), property_challengeResponse_already_set);
            m_result->setString("challengeResponse", value);
            return castState<ChallengeResponseSet>();
        }

        operator RefPtr<WebSocketResponse>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<WebSocketResponse>*>(&m_result);
        }

        operator PassRefPtr<WebSocketResponse> ()
        {
            return RefPtr<WebSocketResponse>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<WebSocketResponse> result = WebSocketResponse::create()
     *     .setStatus(...)
     *     .setStatusText(...)
     *     .setHeaders(...)
     *     .setChallengeResponse(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new WebSocketResponse()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* Information about the cached resource. */
class CachedResource : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        TypeSet = 1 << 1,
        BodySizeSet = 1 << 2,
        AllFieldsSet = (UrlSet | TypeSet | BodySizeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CachedResource> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CachedResource;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | TypeSet>& setType(TypeBuilder::Page::ResourceType::Enum value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type", value);
            return castState<TypeSet>();
        }

        Builder<STATE | BodySizeSet>& setBodySize(double value)
        {
            COMPILE_ASSERT(!(STATE & BodySizeSet), property_bodySize_already_set);
            m_result->setNumber("bodySize", value);
            return castState<BodySizeSet>();
        }

        operator RefPtr<CachedResource>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CachedResource>*>(&m_result);
        }

        operator PassRefPtr<CachedResource> ()
        {
            return RefPtr<CachedResource>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CachedResource> result = CachedResource::create()
     *     .setUrl(...)
     *     .setType(...)
     *     .setBodySize(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new CachedResource()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setResponse(/*PassRefPtr<TypeBuilder::Network::Response>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("response", value);
    }
};

/* Information about the request initiator. */
class Initiator : public InspectorObject {
public:
    // Named after property name 'type' while generating Initiator.
    struct Type {
        enum Enum {
            Parser = 38,
            Script = 39,
            Other = 25,
        };
    }; // struct Type

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Initiator> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Initiator;
    public:

        Builder<STATE | TypeSet>& setType(Type::Enum value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type", value);
            return castState<TypeSet>();
        }

        operator RefPtr<Initiator>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Initiator>*>(&m_result);
        }

        operator PassRefPtr<Initiator> ()
        {
            return RefPtr<Initiator>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Initiator> result = Initiator::create()
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new Initiator()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setStackTrace(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::Console::CallFrame> >*/ PassRefPtr<InspectorArray> value)
    {
        this->setArray("stackTrace", value);
    }

    void setUrl(const String& value)
    {
        this->setString("url", value);
    }

    void setLineNumber(double value)
    {
        this->setNumber("lineNumber", value);
    }
};

} // Network

#if ENABLE(SQL_DATABASE)
namespace Database {
/* Database object. */
class Database : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        DomainSet = 1 << 1,
        NameSet = 1 << 2,
        VersionSet = 1 << 3,
        AllFieldsSet = (IdSet | DomainSet | NameSet | VersionSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Database> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Database;
    public:

        Builder<STATE | IdSet>& setId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & IdSet), property_id_already_set);
            m_result->setString("id", value);
            return castState<IdSet>();
        }

        Builder<STATE | DomainSet>& setDomain(const String& value)
        {
            COMPILE_ASSERT(!(STATE & DomainSet), property_domain_already_set);
            m_result->setString("domain", value);
            return castState<DomainSet>();
        }

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | VersionSet>& setVersion(const String& value)
        {
            COMPILE_ASSERT(!(STATE & VersionSet), property_version_already_set);
            m_result->setString("version", value);
            return castState<VersionSet>();
        }

        operator RefPtr<Database>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Database>*>(&m_result);
        }

        operator PassRefPtr<Database> ()
        {
            return RefPtr<Database>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Database> result = Database::create()
     *     .setId(...)
     *     .setDomain(...)
     *     .setName(...)
     *     .setVersion(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new Database()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

} // Database

#endif // ENABLE(SQL_DATABASE)
#if ENABLE(INDEXED_DATABASE)
namespace IndexedDB {
/* Security origin with database names. */
class SecurityOriginWithDatabaseNames : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        SecurityOriginSet = 1 << 0,
        DatabaseNamesSet = 1 << 1,
        AllFieldsSet = (SecurityOriginSet | DatabaseNamesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<SecurityOriginWithDatabaseNames> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class SecurityOriginWithDatabaseNames;
    public:

        Builder<STATE | SecurityOriginSet>& setSecurityOrigin(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SecurityOriginSet), property_securityOrigin_already_set);
            m_result->setString("securityOrigin", value);
            return castState<SecurityOriginSet>();
        }

        Builder<STATE | DatabaseNamesSet>& setDatabaseNames(/*PassRefPtr<TypeBuilder::Array<String> >*/ PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & DatabaseNamesSet), property_databaseNames_already_set);
            m_result->setArray("databaseNames", value);
            return castState<DatabaseNamesSet>();
        }

        operator RefPtr<SecurityOriginWithDatabaseNames>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<SecurityOriginWithDatabaseNames>*>(&m_result);
        }

        operator PassRefPtr<SecurityOriginWithDatabaseNames> ()
        {
            return RefPtr<SecurityOriginWithDatabaseNames>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SecurityOriginWithDatabaseNames> result = SecurityOriginWithDatabaseNames::create()
     *     .setSecurityOrigin(...)
     *     .setDatabaseNames(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new SecurityOriginWithDatabaseNames()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* Database with an array of object stores. */
class DatabaseWithObjectStores : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        VersionSet = 1 << 1,
        ObjectStoresSet = 1 << 2,
        AllFieldsSet = (NameSet | VersionSet | ObjectStoresSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<DatabaseWithObjectStores> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class DatabaseWithObjectStores;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | VersionSet>& setVersion(const String& value)
        {
            COMPILE_ASSERT(!(STATE & VersionSet), property_version_already_set);
            m_result->setString("version", value);
            return castState<VersionSet>();
        }

        Builder<STATE | ObjectStoresSet>& setObjectStores(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::IndexedDB::ObjectStore> >*/ PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & ObjectStoresSet), property_objectStores_already_set);
            m_result->setArray("objectStores", value);
            return castState<ObjectStoresSet>();
        }

        operator RefPtr<DatabaseWithObjectStores>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<DatabaseWithObjectStores>*>(&m_result);
        }

        operator PassRefPtr<DatabaseWithObjectStores> ()
        {
            return RefPtr<DatabaseWithObjectStores>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<DatabaseWithObjectStores> result = DatabaseWithObjectStores::create()
     *     .setName(...)
     *     .setVersion(...)
     *     .setObjectStores(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new DatabaseWithObjectStores()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* Object store. */
class ObjectStore : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        KeyPathSet = 1 << 1,
        IndexesSet = 1 << 2,
        AllFieldsSet = (NameSet | KeyPathSet | IndexesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<ObjectStore> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ObjectStore;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | KeyPathSet>& setKeyPath(const String& value)
        {
            COMPILE_ASSERT(!(STATE & KeyPathSet), property_keyPath_already_set);
            m_result->setString("keyPath", value);
            return castState<KeyPathSet>();
        }

        Builder<STATE | IndexesSet>& setIndexes(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::IndexedDB::ObjectStoreIndex> >*/ PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & IndexesSet), property_indexes_already_set);
            m_result->setArray("indexes", value);
            return castState<IndexesSet>();
        }

        operator RefPtr<ObjectStore>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<ObjectStore>*>(&m_result);
        }

        operator PassRefPtr<ObjectStore> ()
        {
            return RefPtr<ObjectStore>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ObjectStore> result = ObjectStore::create()
     *     .setName(...)
     *     .setKeyPath(...)
     *     .setIndexes(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new ObjectStore()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* Object store index. */
class ObjectStoreIndex : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        KeyPathSet = 1 << 1,
        UniqueSet = 1 << 2,
        MultiEntrySet = 1 << 3,
        AllFieldsSet = (NameSet | KeyPathSet | UniqueSet | MultiEntrySet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<ObjectStoreIndex> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ObjectStoreIndex;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | KeyPathSet>& setKeyPath(const String& value)
        {
            COMPILE_ASSERT(!(STATE & KeyPathSet), property_keyPath_already_set);
            m_result->setString("keyPath", value);
            return castState<KeyPathSet>();
        }

        Builder<STATE | UniqueSet>& setUnique(bool value)
        {
            COMPILE_ASSERT(!(STATE & UniqueSet), property_unique_already_set);
            m_result->setBoolean("unique", value);
            return castState<UniqueSet>();
        }

        Builder<STATE | MultiEntrySet>& setMultiEntry(bool value)
        {
            COMPILE_ASSERT(!(STATE & MultiEntrySet), property_multiEntry_already_set);
            m_result->setBoolean("multiEntry", value);
            return castState<MultiEntrySet>();
        }

        operator RefPtr<ObjectStoreIndex>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<ObjectStoreIndex>*>(&m_result);
        }

        operator PassRefPtr<ObjectStoreIndex> ()
        {
            return RefPtr<ObjectStoreIndex>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ObjectStoreIndex> result = ObjectStoreIndex::create()
     *     .setName(...)
     *     .setKeyPath(...)
     *     .setUnique(...)
     *     .setMultiEntry(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new ObjectStoreIndex()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* Key. */
class Key : public InspectorObject {
public:
    // Named after property name 'type' while generating Key.
    struct Type {
        enum Enum {
            Number = 12,
            String = 11,
            Date = 18,
            Array = 14,
        };
    }; // struct Type

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Key> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Key;
    public:

        Builder<STATE | TypeSet>& setType(Type::Enum value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type", value);
            return castState<TypeSet>();
        }

        operator RefPtr<Key>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Key>*>(&m_result);
        }

        operator PassRefPtr<Key> ()
        {
            return RefPtr<Key>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Key> result = Key::create()
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new Key()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setNumber(double value)
    {
        this->setNumber("number", value);
    }
    using InspectorObject::setNumber;


    void setString(const String& value)
    {
        this->setString("string", value);
    }
    using InspectorObject::setString;


    void setDate(double value)
    {
        this->setNumber("date", value);
    }

    void setArray(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::IndexedDB::Key> >*/ PassRefPtr<InspectorArray> value)
    {
        this->setArray("array", value);
    }
    using InspectorObject::setArray;

};

/* Key range. */
class KeyRange : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        LowerOpenSet = 1 << 0,
        UpperOpenSet = 1 << 1,
        AllFieldsSet = (LowerOpenSet | UpperOpenSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<KeyRange> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class KeyRange;
    public:

        Builder<STATE | LowerOpenSet>& setLowerOpen(bool value)
        {
            COMPILE_ASSERT(!(STATE & LowerOpenSet), property_lowerOpen_already_set);
            m_result->setBoolean("lowerOpen", value);
            return castState<LowerOpenSet>();
        }

        Builder<STATE | UpperOpenSet>& setUpperOpen(bool value)
        {
            COMPILE_ASSERT(!(STATE & UpperOpenSet), property_upperOpen_already_set);
            m_result->setBoolean("upperOpen", value);
            return castState<UpperOpenSet>();
        }

        operator RefPtr<KeyRange>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<KeyRange>*>(&m_result);
        }

        operator PassRefPtr<KeyRange> ()
        {
            return RefPtr<KeyRange>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<KeyRange> result = KeyRange::create()
     *     .setLowerOpen(...)
     *     .setUpperOpen(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new KeyRange()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setLower(/*PassRefPtr<TypeBuilder::IndexedDB::Key>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("lower", value);
    }

    void setUpper(/*PassRefPtr<TypeBuilder::IndexedDB::Key>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("upper", value);
    }
};

/* Key. */
class DataEntry : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        KeySet = 1 << 0,
        PrimaryKeySet = 1 << 1,
        ValueSet = 1 << 2,
        AllFieldsSet = (KeySet | PrimaryKeySet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<DataEntry> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class DataEntry;
    public:

        Builder<STATE | KeySet>& setKey(/*PassRefPtr<TypeBuilder::IndexedDB::Key>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & KeySet), property_key_already_set);
            m_result->setObject("key", value);
            return castState<KeySet>();
        }

        Builder<STATE | PrimaryKeySet>& setPrimaryKey(/*PassRefPtr<TypeBuilder::IndexedDB::Key>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & PrimaryKeySet), property_primaryKey_already_set);
            m_result->setObject("primaryKey", value);
            return castState<PrimaryKeySet>();
        }

        Builder<STATE | ValueSet>& setValue(/*PassRefPtr<TypeBuilder::Runtime::RemoteObject>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setObject("value", value);
            return castState<ValueSet>();
        }

        operator RefPtr<DataEntry>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<DataEntry>*>(&m_result);
        }

        operator PassRefPtr<DataEntry> ()
        {
            return RefPtr<DataEntry>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<DataEntry> result = DataEntry::create()
     *     .setKey(...)
     *     .setPrimaryKey(...)
     *     .setValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new DataEntry()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

} // IndexedDB

#endif // ENABLE(INDEXED_DATABASE)
namespace DOMStorage {
/* DOM Storage entry. */
class Entry : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        HostSet = 1 << 0,
        IsLocalStorageSet = 1 << 1,
        IdSet = 1 << 2,
        AllFieldsSet = (HostSet | IsLocalStorageSet | IdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Entry> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Entry;
    public:

        Builder<STATE | HostSet>& setHost(const String& value)
        {
            COMPILE_ASSERT(!(STATE & HostSet), property_host_already_set);
            m_result->setString("host", value);
            return castState<HostSet>();
        }

        Builder<STATE | IsLocalStorageSet>& setIsLocalStorage(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsLocalStorageSet), property_isLocalStorage_already_set);
            m_result->setBoolean("isLocalStorage", value);
            return castState<IsLocalStorageSet>();
        }

        Builder<STATE | IdSet>& setId(double value)
        {
            COMPILE_ASSERT(!(STATE & IdSet), property_id_already_set);
            m_result->setNumber("id", value);
            return castState<IdSet>();
        }

        operator RefPtr<Entry>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Entry>*>(&m_result);
        }

        operator PassRefPtr<Entry> ()
        {
            return RefPtr<Entry>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Entry> result = Entry::create()
     *     .setHost(...)
     *     .setIsLocalStorage(...)
     *     .setId(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new Entry()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

} // DOMStorage

namespace ApplicationCache {
/* Detailed application cache resource information. */
class ApplicationCacheResource : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        SizeSet = 1 << 1,
        TypeSet = 1 << 2,
        AllFieldsSet = (UrlSet | SizeSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<ApplicationCacheResource> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ApplicationCacheResource;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | SizeSet>& setSize(int value)
        {
            COMPILE_ASSERT(!(STATE & SizeSet), property_size_already_set);
            m_result->setNumber("size", value);
            return castState<SizeSet>();
        }

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type", value);
            return castState<TypeSet>();
        }

        operator RefPtr<ApplicationCacheResource>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<ApplicationCacheResource>*>(&m_result);
        }

        operator PassRefPtr<ApplicationCacheResource> ()
        {
            return RefPtr<ApplicationCacheResource>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ApplicationCacheResource> result = ApplicationCacheResource::create()
     *     .setUrl(...)
     *     .setSize(...)
     *     .setType(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new ApplicationCacheResource()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* Detailed application cache information. */
class ApplicationCache : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        ManifestURLSet = 1 << 0,
        SizeSet = 1 << 1,
        CreationTimeSet = 1 << 2,
        UpdateTimeSet = 1 << 3,
        ResourcesSet = 1 << 4,
        AllFieldsSet = (ManifestURLSet | SizeSet | CreationTimeSet | UpdateTimeSet | ResourcesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<ApplicationCache> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ApplicationCache;
    public:

        Builder<STATE | ManifestURLSet>& setManifestURL(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ManifestURLSet), property_manifestURL_already_set);
            m_result->setString("manifestURL", value);
            return castState<ManifestURLSet>();
        }

        Builder<STATE | SizeSet>& setSize(double value)
        {
            COMPILE_ASSERT(!(STATE & SizeSet), property_size_already_set);
            m_result->setNumber("size", value);
            return castState<SizeSet>();
        }

        Builder<STATE | CreationTimeSet>& setCreationTime(double value)
        {
            COMPILE_ASSERT(!(STATE & CreationTimeSet), property_creationTime_already_set);
            m_result->setNumber("creationTime", value);
            return castState<CreationTimeSet>();
        }

        Builder<STATE | UpdateTimeSet>& setUpdateTime(double value)
        {
            COMPILE_ASSERT(!(STATE & UpdateTimeSet), property_updateTime_already_set);
            m_result->setNumber("updateTime", value);
            return castState<UpdateTimeSet>();
        }

        Builder<STATE | ResourcesSet>& setResources(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::ApplicationCache::ApplicationCacheResource> >*/ PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & ResourcesSet), property_resources_already_set);
            m_result->setArray("resources", value);
            return castState<ResourcesSet>();
        }

        operator RefPtr<ApplicationCache>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<ApplicationCache>*>(&m_result);
        }

        operator PassRefPtr<ApplicationCache> ()
        {
            return RefPtr<ApplicationCache>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ApplicationCache> result = ApplicationCache::create()
     *     .setManifestURL(...)
     *     .setSize(...)
     *     .setCreationTime(...)
     *     .setUpdateTime(...)
     *     .setResources(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new ApplicationCache()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* Frame identifier - manifest URL pair. */
class FrameWithManifest : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        FrameIdSet = 1 << 0,
        ManifestURLSet = 1 << 1,
        StatusSet = 1 << 2,
        AllFieldsSet = (FrameIdSet | ManifestURLSet | StatusSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<FrameWithManifest> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class FrameWithManifest;
    public:

        Builder<STATE | FrameIdSet>& setFrameId(/*const TypeBuilder::Network::FrameId&*/ const String& value)
        {
            COMPILE_ASSERT(!(STATE & FrameIdSet), property_frameId_already_set);
            m_result->setString("frameId", value);
            return castState<FrameIdSet>();
        }

        Builder<STATE | ManifestURLSet>& setManifestURL(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ManifestURLSet), property_manifestURL_already_set);
            m_result->setString("manifestURL", value);
            return castState<ManifestURLSet>();
        }

        Builder<STATE | StatusSet>& setStatus(int value)
        {
            COMPILE_ASSERT(!(STATE & StatusSet), property_status_already_set);
            m_result->setNumber("status", value);
            return castState<StatusSet>();
        }

        operator RefPtr<FrameWithManifest>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<FrameWithManifest>*>(&m_result);
        }

        operator PassRefPtr<FrameWithManifest> ()
        {
            return RefPtr<FrameWithManifest>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<FrameWithManifest> result = FrameWithManifest::create()
     *     .setFrameId(...)
     *     .setManifestURL(...)
     *     .setStatus(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new FrameWithManifest()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

} // ApplicationCache

namespace DOM {
/* DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type. */
class Node : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        NodeIdSet = 1 << 0,
        NodeTypeSet = 1 << 1,
        NodeNameSet = 1 << 2,
        LocalNameSet = 1 << 3,
        NodeValueSet = 1 << 4,
        AllFieldsSet = (NodeIdSet | NodeTypeSet | NodeNameSet | LocalNameSet | NodeValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Node> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Node;
    public:

        Builder<STATE | NodeIdSet>& setNodeId(int value)
        {
            COMPILE_ASSERT(!(STATE & NodeIdSet), property_nodeId_already_set);
            m_result->setNumber("nodeId", value);
            return castState<NodeIdSet>();
        }

        Builder<STATE | NodeTypeSet>& setNodeType(int value)
        {
            COMPILE_ASSERT(!(STATE & NodeTypeSet), property_nodeType_already_set);
            m_result->setNumber("nodeType", value);
            return castState<NodeTypeSet>();
        }

        Builder<STATE | NodeNameSet>& setNodeName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NodeNameSet), property_nodeName_already_set);
            m_result->setString("nodeName", value);
            return castState<NodeNameSet>();
        }

        Builder<STATE | LocalNameSet>& setLocalName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & LocalNameSet), property_localName_already_set);
            m_result->setString("localName", value);
            return castState<LocalNameSet>();
        }

        Builder<STATE | NodeValueSet>& setNodeValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NodeValueSet), property_nodeValue_already_set);
            m_result->setString("nodeValue", value);
            return castState<NodeValueSet>();
        }

        operator RefPtr<Node>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Node>*>(&m_result);
        }

        operator PassRefPtr<Node> ()
        {
            return RefPtr<Node>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Node> result = Node::create()
     *     .setNodeId(...)
     *     .setNodeType(...)
     *     .setNodeName(...)
     *     .setLocalName(...)
     *     .setNodeValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new Node()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setChildNodeCount(int value)
    {
        this->setNumber("childNodeCount", value);
    }

    void setChildren(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::DOM::Node> >*/ PassRefPtr<InspectorArray> value)
    {
        this->setArray("children", value);
    }

    void setAttributes(/*PassRefPtr<TypeBuilder::Array<String> >*/ PassRefPtr<InspectorArray> value)
    {
        this->setArray("attributes", value);
    }

    void setDocumentURL(const String& value)
    {
        this->setString("documentURL", value);
    }

    void setPublicId(const String& value)
    {
        this->setString("publicId", value);
    }

    void setSystemId(const String& value)
    {
        this->setString("systemId", value);
    }

    void setInternalSubset(const String& value)
    {
        this->setString("internalSubset", value);
    }

    void setXmlVersion(const String& value)
    {
        this->setString("xmlVersion", value);
    }

    void setName(const String& value)
    {
        this->setString("name", value);
    }

    void setValue(const String& value)
    {
        this->setString("value", value);
    }
    using InspectorObject::setValue;


    void setContentDocument(/*PassRefPtr<TypeBuilder::DOM::Node>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("contentDocument", value);
    }

    void setShadowRoots(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::DOM::Node> >*/ PassRefPtr<InspectorArray> value)
    {
        this->setArray("shadowRoots", value);
    }
};

/* DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type. */
class EventListener : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        UseCaptureSet = 1 << 1,
        IsAttributeSet = 1 << 2,
        NodeIdSet = 1 << 3,
        HandlerBodySet = 1 << 4,
        AllFieldsSet = (TypeSet | UseCaptureSet | IsAttributeSet | NodeIdSet | HandlerBodySet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<EventListener> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class EventListener;
    public:

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type", value);
            return castState<TypeSet>();
        }

        Builder<STATE | UseCaptureSet>& setUseCapture(bool value)
        {
            COMPILE_ASSERT(!(STATE & UseCaptureSet), property_useCapture_already_set);
            m_result->setBoolean("useCapture", value);
            return castState<UseCaptureSet>();
        }

        Builder<STATE | IsAttributeSet>& setIsAttribute(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsAttributeSet), property_isAttribute_already_set);
            m_result->setBoolean("isAttribute", value);
            return castState<IsAttributeSet>();
        }

        Builder<STATE | NodeIdSet>& setNodeId(int value)
        {
            COMPILE_ASSERT(!(STATE & NodeIdSet), property_nodeId_already_set);
            m_result->setNumber("nodeId", value);
            return castState<NodeIdSet>();
        }

        Builder<STATE | HandlerBodySet>& setHandlerBody(const String& value)
        {
            COMPILE_ASSERT(!(STATE & HandlerBodySet), property_handlerBody_already_set);
            m_result->setString("handlerBody", value);
            return castState<HandlerBodySet>();
        }

        operator RefPtr<EventListener>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<EventListener>*>(&m_result);
        }

        operator PassRefPtr<EventListener> ()
        {
            return RefPtr<EventListener>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<EventListener> result = EventListener::create()
     *     .setType(...)
     *     .setUseCapture(...)
     *     .setIsAttribute(...)
     *     .setNodeId(...)
     *     .setHandlerBody(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new EventListener()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setLocation(/*PassRefPtr<TypeBuilder::Debugger::Location>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("location", value);
    }
};

/* A structure holding an RGBA color. */
// Type originally was named 'RGBA'.
class Rgba : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        RSet = 1 << 0,
        GSet = 1 << 1,
        BSet = 1 << 2,
        AllFieldsSet = (RSet | GSet | BSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Rgba> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Rgba;
    public:

        Builder<STATE | RSet>& setR(int value)
        {
            COMPILE_ASSERT(!(STATE & RSet), property_r_already_set);
            m_result->setNumber("r", value);
            return castState<RSet>();
        }

        Builder<STATE | GSet>& setG(int value)
        {
            COMPILE_ASSERT(!(STATE & GSet), property_g_already_set);
            m_result->setNumber("g", value);
            return castState<GSet>();
        }

        Builder<STATE | BSet>& setB(int value)
        {
            COMPILE_ASSERT(!(STATE & BSet), property_b_already_set);
            m_result->setNumber("b", value);
            return castState<BSet>();
        }

        operator RefPtr<Rgba>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Rgba>*>(&m_result);
        }

        operator PassRefPtr<Rgba> ()
        {
            return RefPtr<Rgba>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Rgba> result = Rgba::create()
     *     .setR(...)
     *     .setG(...)
     *     .setB(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new Rgba()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setA(double value)
    {
        this->setNumber("a", value);
    }
};

/* Configuration data for the highlighting of page elements. */
class HighlightConfig : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<HighlightConfig> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class HighlightConfig;
    public:

        operator RefPtr<HighlightConfig>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<HighlightConfig>*>(&m_result);
        }

        operator PassRefPtr<HighlightConfig> ()
        {
            return RefPtr<HighlightConfig>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<HighlightConfig> result = HighlightConfig::create();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new HighlightConfig()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setShowInfo(bool value)
    {
        this->setBoolean("showInfo", value);
    }

    void setContentColor(/*PassRefPtr<TypeBuilder::DOM::Rgba>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("contentColor", value);
    }

    void setPaddingColor(/*PassRefPtr<TypeBuilder::DOM::Rgba>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("paddingColor", value);
    }

    void setBorderColor(/*PassRefPtr<TypeBuilder::DOM::Rgba>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("borderColor", value);
    }

    void setMarginColor(/*PassRefPtr<TypeBuilder::DOM::Rgba>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("marginColor", value);
    }
};

} // DOM

namespace CSS {
/* This object identifies a CSS style in a unique way. */
class CSSStyleId : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        OrdinalSet = 1 << 1,
        AllFieldsSet = (StyleSheetIdSet | OrdinalSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSStyleId> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSStyleId;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(/*const TypeBuilder::CSS::StyleSheetId&*/ const String& value)
        {
            COMPILE_ASSERT(!(STATE & StyleSheetIdSet), property_styleSheetId_already_set);
            m_result->setString("styleSheetId", value);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | OrdinalSet>& setOrdinal(int value)
        {
            COMPILE_ASSERT(!(STATE & OrdinalSet), property_ordinal_already_set);
            m_result->setNumber("ordinal", value);
            return castState<OrdinalSet>();
        }

        operator RefPtr<CSSStyleId>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSStyleId>*>(&m_result);
        }

        operator PassRefPtr<CSSStyleId> ()
        {
            return RefPtr<CSSStyleId>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyleId> result = CSSStyleId::create()
     *     .setStyleSheetId(...)
     *     .setOrdinal(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new CSSStyleId()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* This object identifies a CSS rule in a unique way. */
class CSSRuleId : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        OrdinalSet = 1 << 1,
        AllFieldsSet = (StyleSheetIdSet | OrdinalSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSRuleId> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSRuleId;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(/*const TypeBuilder::CSS::StyleSheetId&*/ const String& value)
        {
            COMPILE_ASSERT(!(STATE & StyleSheetIdSet), property_styleSheetId_already_set);
            m_result->setString("styleSheetId", value);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | OrdinalSet>& setOrdinal(int value)
        {
            COMPILE_ASSERT(!(STATE & OrdinalSet), property_ordinal_already_set);
            m_result->setNumber("ordinal", value);
            return castState<OrdinalSet>();
        }

        operator RefPtr<CSSRuleId>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSRuleId>*>(&m_result);
        }

        operator PassRefPtr<CSSRuleId> ()
        {
            return RefPtr<CSSRuleId>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSRuleId> result = CSSRuleId::create()
     *     .setStyleSheetId(...)
     *     .setOrdinal(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new CSSRuleId()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* CSS rule collection for a single pseudo style. */
class PseudoIdRules : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        PseudoIdSet = 1 << 0,
        RulesSet = 1 << 1,
        AllFieldsSet = (PseudoIdSet | RulesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<PseudoIdRules> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class PseudoIdRules;
    public:

        Builder<STATE | PseudoIdSet>& setPseudoId(int value)
        {
            COMPILE_ASSERT(!(STATE & PseudoIdSet), property_pseudoId_already_set);
            m_result->setNumber("pseudoId", value);
            return castState<PseudoIdSet>();
        }

        Builder<STATE | RulesSet>& setRules(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSRule> >*/ PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & RulesSet), property_rules_already_set);
            m_result->setArray("rules", value);
            return castState<RulesSet>();
        }

        operator RefPtr<PseudoIdRules>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<PseudoIdRules>*>(&m_result);
        }

        operator PassRefPtr<PseudoIdRules> ()
        {
            return RefPtr<PseudoIdRules>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<PseudoIdRules> result = PseudoIdRules::create()
     *     .setPseudoId(...)
     *     .setRules(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new PseudoIdRules()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* CSS rule collection for a single pseudo style. */
class InheritedStyleEntry : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        MatchedCSSRulesSet = 1 << 0,
        AllFieldsSet = (MatchedCSSRulesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<InheritedStyleEntry> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class InheritedStyleEntry;
    public:

        Builder<STATE | MatchedCSSRulesSet>& setMatchedCSSRules(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSRule> >*/ PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & MatchedCSSRulesSet), property_matchedCSSRules_already_set);
            m_result->setArray("matchedCSSRules", value);
            return castState<MatchedCSSRulesSet>();
        }

        operator RefPtr<InheritedStyleEntry>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<InheritedStyleEntry>*>(&m_result);
        }

        operator PassRefPtr<InheritedStyleEntry> ()
        {
            return RefPtr<InheritedStyleEntry>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<InheritedStyleEntry> result = InheritedStyleEntry::create()
     *     .setMatchedCSSRules(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new InheritedStyleEntry()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setInlineStyle(/*PassRefPtr<TypeBuilder::CSS::CSSStyle>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("inlineStyle", value);
    }
};

/* CSS style information for a DOM style attribute. */
class CSSStyleAttribute : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        StyleSet = 1 << 1,
        AllFieldsSet = (NameSet | StyleSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSStyleAttribute> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSStyleAttribute;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | StyleSet>& setStyle(/*PassRefPtr<TypeBuilder::CSS::CSSStyle>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & StyleSet), property_style_already_set);
            m_result->setObject("style", value);
            return castState<StyleSet>();
        }

        operator RefPtr<CSSStyleAttribute>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSStyleAttribute>*>(&m_result);
        }

        operator PassRefPtr<CSSStyleAttribute> ()
        {
            return RefPtr<CSSStyleAttribute>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyleAttribute> result = CSSStyleAttribute::create()
     *     .setName(...)
     *     .setStyle(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new CSSStyleAttribute()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* CSS stylesheet metainformation. */
class CSSStyleSheetHeader : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        SourceURLSet = 1 << 1,
        TitleSet = 1 << 2,
        DisabledSet = 1 << 3,
        AllFieldsSet = (StyleSheetIdSet | SourceURLSet | TitleSet | DisabledSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSStyleSheetHeader> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSStyleSheetHeader;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(/*const TypeBuilder::CSS::StyleSheetId&*/ const String& value)
        {
            COMPILE_ASSERT(!(STATE & StyleSheetIdSet), property_styleSheetId_already_set);
            m_result->setString("styleSheetId", value);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | SourceURLSet>& setSourceURL(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SourceURLSet), property_sourceURL_already_set);
            m_result->setString("sourceURL", value);
            return castState<SourceURLSet>();
        }

        Builder<STATE | TitleSet>& setTitle(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TitleSet), property_title_already_set);
            m_result->setString("title", value);
            return castState<TitleSet>();
        }

        Builder<STATE | DisabledSet>& setDisabled(bool value)
        {
            COMPILE_ASSERT(!(STATE & DisabledSet), property_disabled_already_set);
            m_result->setBoolean("disabled", value);
            return castState<DisabledSet>();
        }

        operator RefPtr<CSSStyleSheetHeader>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSStyleSheetHeader>*>(&m_result);
        }

        operator PassRefPtr<CSSStyleSheetHeader> ()
        {
            return RefPtr<CSSStyleSheetHeader>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyleSheetHeader> result = CSSStyleSheetHeader::create()
     *     .setStyleSheetId(...)
     *     .setSourceURL(...)
     *     .setTitle(...)
     *     .setDisabled(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new CSSStyleSheetHeader()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* CSS stylesheet contents. */
class CSSStyleSheetBody : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        RulesSet = 1 << 1,
        AllFieldsSet = (StyleSheetIdSet | RulesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSStyleSheetBody> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSStyleSheetBody;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(/*const TypeBuilder::CSS::StyleSheetId&*/ const String& value)
        {
            COMPILE_ASSERT(!(STATE & StyleSheetIdSet), property_styleSheetId_already_set);
            m_result->setString("styleSheetId", value);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | RulesSet>& setRules(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSRule> >*/ PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & RulesSet), property_rules_already_set);
            m_result->setArray("rules", value);
            return castState<RulesSet>();
        }

        operator RefPtr<CSSStyleSheetBody>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSStyleSheetBody>*>(&m_result);
        }

        operator PassRefPtr<CSSStyleSheetBody> ()
        {
            return RefPtr<CSSStyleSheetBody>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyleSheetBody> result = CSSStyleSheetBody::create()
     *     .setStyleSheetId(...)
     *     .setRules(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new CSSStyleSheetBody()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setText(const String& value)
    {
        this->setString("text", value);
    }
};

/* CSS rule representation. */
class CSSRule : public InspectorObject {
public:
    // Named after property name 'origin' while generating CSSRule.
    struct Origin {
        enum Enum {
            User = 40,
            User_agent = 41,
            Inspector = 42,
            Regular = 43,
        };
    }; // struct Origin

    enum {
        NoFieldsSet = 0,
        SelectorTextSet = 1 << 0,
        SourceLineSet = 1 << 1,
        OriginSet = 1 << 2,
        StyleSet = 1 << 3,
        AllFieldsSet = (SelectorTextSet | SourceLineSet | OriginSet | StyleSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSRule> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSRule;
    public:

        Builder<STATE | SelectorTextSet>& setSelectorText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SelectorTextSet), property_selectorText_already_set);
            m_result->setString("selectorText", value);
            return castState<SelectorTextSet>();
        }

        Builder<STATE | SourceLineSet>& setSourceLine(int value)
        {
            COMPILE_ASSERT(!(STATE & SourceLineSet), property_sourceLine_already_set);
            m_result->setNumber("sourceLine", value);
            return castState<SourceLineSet>();
        }

        Builder<STATE | OriginSet>& setOrigin(Origin::Enum value)
        {
            COMPILE_ASSERT(!(STATE & OriginSet), property_origin_already_set);
            m_result->setString("origin", TypeBuilder::getEnumConstantValue(value));
            return castState<OriginSet>();
        }

        Builder<STATE | OriginSet>& setOrigin(const String& value)
        {
            COMPILE_ASSERT(!(STATE & OriginSet), property_origin_already_set);
            m_result->setString("origin", value);
            return castState<OriginSet>();
        }

        Builder<STATE | StyleSet>& setStyle(/*PassRefPtr<TypeBuilder::CSS::CSSStyle>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & StyleSet), property_style_already_set);
            m_result->setObject("style", value);
            return castState<StyleSet>();
        }

        operator RefPtr<CSSRule>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSRule>*>(&m_result);
        }

        operator PassRefPtr<CSSRule> ()
        {
            return RefPtr<CSSRule>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSRule> result = CSSRule::create()
     *     .setSelectorText(...)
     *     .setSourceLine(...)
     *     .setOrigin(...)
     *     .setStyle(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new CSSRule()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setRuleId(/*PassRefPtr<TypeBuilder::CSS::CSSRuleId>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("ruleId", value);
    }

    void setSourceURL(const String& value)
    {
        this->setString("sourceURL", value);
    }

    void setSelectorRange(/*PassRefPtr<TypeBuilder::CSS::SourceRange>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("selectorRange", value);
    }

    void setMedia(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSMedia> >*/ PassRefPtr<InspectorArray> value)
    {
        this->setArray("media", value);
    }
};

/* Text range within a resource. */
class SourceRange : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        StartSet = 1 << 0,
        EndSet = 1 << 1,
        AllFieldsSet = (StartSet | EndSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<SourceRange> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class SourceRange;
    public:

        Builder<STATE | StartSet>& setStart(int value)
        {
            COMPILE_ASSERT(!(STATE & StartSet), property_start_already_set);
            m_result->setNumber("start", value);
            return castState<StartSet>();
        }

        Builder<STATE | EndSet>& setEnd(int value)
        {
            COMPILE_ASSERT(!(STATE & EndSet), property_end_already_set);
            m_result->setNumber("end", value);
            return castState<EndSet>();
        }

        operator RefPtr<SourceRange>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<SourceRange>*>(&m_result);
        }

        operator PassRefPtr<SourceRange> ()
        {
            return RefPtr<SourceRange>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SourceRange> result = SourceRange::create()
     *     .setStart(...)
     *     .setEnd(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new SourceRange()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

class CSSComputedStyleProperty : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (NameSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSComputedStyleProperty> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSComputedStyleProperty;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString("value", value);
            return castState<ValueSet>();
        }

        operator RefPtr<CSSComputedStyleProperty>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSComputedStyleProperty>*>(&m_result);
        }

        operator PassRefPtr<CSSComputedStyleProperty> ()
        {
            return RefPtr<CSSComputedStyleProperty>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSComputedStyleProperty> result = CSSComputedStyleProperty::create()
     *     .setName(...)
     *     .setValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new CSSComputedStyleProperty()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

/* CSS style representation. */
class CSSStyle : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        CssPropertiesSet = 1 << 0,
        ShorthandEntriesSet = 1 << 1,
        AllFieldsSet = (CssPropertiesSet | ShorthandEntriesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSStyle> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSStyle;
    public:

        Builder<STATE | CssPropertiesSet>& setCssProperties(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSProperty> >*/ PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & CssPropertiesSet), property_cssProperties_already_set);
            m_result->setArray("cssProperties", value);
            return castState<CssPropertiesSet>();
        }

        Builder<STATE | ShorthandEntriesSet>& setShorthandEntries(/*PassRefPtr<TypeBuilder::Array<InspectorObject> >*/ PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & ShorthandEntriesSet), property_shorthandEntries_already_set);
            m_result->setArray("shorthandEntries", value);
            return castState<ShorthandEntriesSet>();
        }

        operator RefPtr<CSSStyle>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSStyle>*>(&m_result);
        }

        operator PassRefPtr<CSSStyle> ()
        {
            return RefPtr<CSSStyle>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyle> result = CSSStyle::create()
     *     .setCssProperties(...)
     *     .setShorthandEntries(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new CSSStyle()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setStyleId(/*PassRefPtr<TypeBuilder::CSS::CSSStyleId>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("styleId", value);
    }

    void setCssText(const String& value)
    {
        this->setString("cssText", value);
    }

    void setRange(/*PassRefPtr<TypeBuilder::CSS::SourceRange>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("range", value);
    }

    void setWidth(const String& value)
    {
        this->setString("width", value);
    }

    void setHeight(const String& value)
    {
        this->setString("height", value);
    }
};

/* CSS style effective visual dimensions and source offsets. */
class CSSProperty : public InspectorObject {
public:
    // Named after property name 'status' while generating CSSProperty.
    struct Status {
        enum Enum {
            Active = 44,
            Inactive = 45,
            Disabled = 46,
            Style = 47,
        };
    }; // struct Status

    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (NameSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSProperty> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSProperty;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString("name", value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString("value", value);
            return castState<ValueSet>();
        }

        operator RefPtr<CSSProperty>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSProperty>*>(&m_result);
        }

        operator PassRefPtr<CSSProperty> ()
        {
            return RefPtr<CSSProperty>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSProperty> result = CSSProperty::create()
     *     .setName(...)
     *     .setValue(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new CSSProperty()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setPriority(const String& value)
    {
        this->setString("priority", value);
    }

    void setImplicit(bool value)
    {
        this->setBoolean("implicit", value);
    }

    void setText(const String& value)
    {
        this->setString("text", value);
    }

    void setParsedOk(bool value)
    {
        this->setBoolean("parsedOk", value);
    }

    void setStatus(Status::Enum value)
    {
        this->setString("status", TypeBuilder::getEnumConstantValue(value));
    }

    void setStatus(const String& value)
    {
        this->setString("status", value);
    }

    void setShorthandName(const String& value)
    {
        this->setString("shorthandName", value);
    }

    void setRange(/*PassRefPtr<TypeBuilder::CSS::SourceRange>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("range", value);
    }
};

/* CSS media query descriptor. */
class CSSMedia : public InspectorObject {
public:
    // Named after property name 'source' while generating CSSMedia.
    struct Source {
        enum Enum {
            MediaRule = 48,
            ImportRule = 49,
            LinkedSheet = 50,
            InlineSheet = 51,
        };
    }; // struct Source

    enum {
        NoFieldsSet = 0,
        TextSet = 1 << 0,
        SourceSet = 1 << 1,
        AllFieldsSet = (TextSet | SourceSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSMedia> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSMedia;
    public:

        Builder<STATE | TextSet>& setText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TextSet), property_text_already_set);
            m_result->setString("text", value);
            return castState<TextSet>();
        }

        Builder<STATE | SourceSet>& setSource(Source::Enum value)
        {
            COMPILE_ASSERT(!(STATE & SourceSet), property_source_already_set);
            m_result->setString("source", TypeBuilder::getEnumConstantValue(value));
            return castState<SourceSet>();
        }

        Builder<STATE | SourceSet>& setSource(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SourceSet), property_source_already_set);
            m_result->setString("source", value);
            return castState<SourceSet>();
        }

        operator RefPtr<CSSMedia>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSMedia>*>(&m_result);
        }

        operator PassRefPtr<CSSMedia> ()
        {
            return RefPtr<CSSMedia>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSMedia> result = CSSMedia::create()
     *     .setText(...)
     *     .setSource(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new CSSMedia()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setSourceURL(const String& value)
    {
        this->setString("sourceURL", value);
    }

    void setSourceLine(int value)
    {
        this->setNumber("sourceLine", value);
    }
};

/* CSS selector profile entry. */
class SelectorProfileEntry : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        SelectorSet = 1 << 0,
        UrlSet = 1 << 1,
        LineNumberSet = 1 << 2,
        TimeSet = 1 << 3,
        HitCountSet = 1 << 4,
        MatchCountSet = 1 << 5,
        AllFieldsSet = (SelectorSet | UrlSet | LineNumberSet | TimeSet | HitCountSet | MatchCountSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<SelectorProfileEntry> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class SelectorProfileEntry;
    public:

        Builder<STATE | SelectorSet>& setSelector(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SelectorSet), property_selector_already_set);
            m_result->setString("selector", value);
            return castState<SelectorSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString("url", value);
            return castState<UrlSet>();
        }

        Builder<STATE | LineNumberSet>& setLineNumber(int value)
        {
            COMPILE_ASSERT(!(STATE & LineNumberSet), property_lineNumber_already_set);
            m_result->setNumber("lineNumber", value);
            return castState<LineNumberSet>();
        }

        Builder<STATE | TimeSet>& setTime(double value)
        {
            COMPILE_ASSERT(!(STATE & TimeSet), property_time_already_set);
            m_result->setNumber("time", value);
            return castState<TimeSet>();
        }

        Builder<STATE | HitCountSet>& setHitCount(int value)
        {
            COMPILE_ASSERT(!(STATE & HitCountSet), property_hitCount_already_set);
            m_result->setNumber("hitCount", value);
            return castState<HitCountSet>();
        }

        Builder<STATE | MatchCountSet>& setMatchCount(int value)
        {
            COMPILE_ASSERT(!(STATE & MatchCountSet), property_matchCount_already_set);
            m_result->setNumber("matchCount", value);
            return castState<MatchCountSet>();
        }

        operator RefPtr<SelectorProfileEntry>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<SelectorProfileEntry>*>(&m_result);
        }

        operator PassRefPtr<SelectorProfileEntry> ()
        {
            return RefPtr<SelectorProfileEntry>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SelectorProfileEntry> result = SelectorProfileEntry::create()
     *     .setSelector(...)
     *     .setUrl(...)
     *     .setLineNumber(...)
     *     .setTime(...)
     *     .setHitCount(...)
     *     .setMatchCount(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new SelectorProfileEntry()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

class SelectorProfile : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        TotalTimeSet = 1 << 0,
        DataSet = 1 << 1,
        AllFieldsSet = (TotalTimeSet | DataSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<SelectorProfile> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class SelectorProfile;
    public:

        Builder<STATE | TotalTimeSet>& setTotalTime(double value)
        {
            COMPILE_ASSERT(!(STATE & TotalTimeSet), property_totalTime_already_set);
            m_result->setNumber("totalTime", value);
            return castState<TotalTimeSet>();
        }

        Builder<STATE | DataSet>& setData(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::CSS::SelectorProfileEntry> >*/ PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & DataSet), property_data_already_set);
            m_result->setArray("data", value);
            return castState<DataSet>();
        }

        operator RefPtr<SelectorProfile>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<SelectorProfile>*>(&m_result);
        }

        operator PassRefPtr<SelectorProfile> ()
        {
            return RefPtr<SelectorProfile>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SelectorProfile> result = SelectorProfile::create()
     *     .setTotalTime(...)
     *     .setData(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new SelectorProfile()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
};

} // CSS

namespace Timeline {
/* Timeline record contains information about the recorded activity. */
class TimelineEvent : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        DataSet = 1 << 1,
        AllFieldsSet = (TypeSet | DataSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<TimelineEvent> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class TimelineEvent;
    public:

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type", value);
            return castState<TypeSet>();
        }

        Builder<STATE | DataSet>& setData(PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & DataSet), property_data_already_set);
            m_result->setObject("data", value);
            return castState<DataSet>();
        }

        operator RefPtr<TimelineEvent>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<TimelineEvent>*>(&m_result);
        }

        operator PassRefPtr<TimelineEvent> ()
        {
            return RefPtr<TimelineEvent>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<TimelineEvent> result = TimelineEvent::create()
     *     .setType(...)
     *     .setData(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new TimelineEvent()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setChildren(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::Timeline::TimelineEvent> >*/ PassRefPtr<InspectorArray> value)
    {
        this->setArray("children", value);
    }
};

} // Timeline

#if ENABLE(JAVASCRIPT_DEBUGGER)
namespace Debugger {
/* Location in the source code. */
class Location : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        ScriptIdSet = 1 << 0,
        LineNumberSet = 1 << 1,
        AllFieldsSet = (ScriptIdSet | LineNumberSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Location> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Location;
    public:

        Builder<STATE | ScriptIdSet>& setScriptId(/*const TypeBuilder::Debugger::ScriptId&*/ const String& value)
        {
            COMPILE_ASSERT(!(STATE & ScriptIdSet), property_scriptId_already_set);
            m_result->setString("scriptId", value);
            return castState<ScriptIdSet>();
        }

        Builder<STATE | LineNumberSet>& setLineNumber(int value)
        {
            COMPILE_ASSERT(!(STATE & LineNumberSet), property_lineNumber_already_set);
            m_result->setNumber("lineNumber", value);
            return castState<LineNumberSet>();
        }

        operator RefPtr<Location>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Location>*>(&m_result);
        }

        operator PassRefPtr<Location> ()
        {
            return RefPtr<Location>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Location> result = Location::create()
     *     .setScriptId(...)
     *     .setLineNumber(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new Location()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setColumnNumber(int value)
    {
        this->setNumber("columnNumber", value);
    }
#if !ASSERT_DISABLED
    static void assertCorrectValue(InspectorValue* value);
#endif  // !ASSERT_DISABLED
};

/* Information about the function. */
class FunctionDetails : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        LocationSet = 1 << 0,
        AllFieldsSet = (LocationSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<FunctionDetails> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class FunctionDetails;
    public:

        Builder<STATE | LocationSet>& setLocation(/*PassRefPtr<TypeBuilder::Debugger::Location>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & LocationSet), property_location_already_set);
            m_result->setObject("location", value);
            return castState<LocationSet>();
        }

        operator RefPtr<FunctionDetails>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<FunctionDetails>*>(&m_result);
        }

        operator PassRefPtr<FunctionDetails> ()
        {
            return RefPtr<FunctionDetails>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<FunctionDetails> result = FunctionDetails::create()
     *     .setLocation(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new FunctionDetails()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;

    void setName(const String& value)
    {
        this->setString("name", value);
    }

    void setDisplayName(const String& value)
    {
        this->setString("displayName", value);
    }

    void setInferredName(const String& value)
    {
        this->setString("inferredName", value);
    }
    static PassRefPtr<FunctionDetails> runtimeCast(PassRefPtr<InspectorValue> value)
    {
        RefPtr<InspectorObject> object;
        bool castRes = value->asObject(&object);
        ASSERT_UNUSED(castRes, castRes);
#if !ASSERT_DISABLED
        assertCorrectValue(object.get());
#endif  // !ASSERT_DISABLED
        COMPILE_ASSERT(sizeof(FunctionDetails) == sizeof(InspectorObject), type_cast_problem);
        return static_cast<FunctionDetails*>(object.get());
    }

#if !ASSERT_DISABLED
    static void assertCorrectValue(InspectorValue* value);
#endif  // !ASSERT_DISABLED
};

/* JavaScript call frame. Array of call frames form the call stack. */
class CallFrame : public InspectorObject {
public:
    enum {
        NoFieldsSet = 0,
        CallFrameIdSet = 1 << 0,
        FunctionNameSet = 1 << 1,
        LocationSet = 1 << 2,
        ScopeChainSet = 1 << 3,
        ThisSet = 1 << 4,
        AllFieldsSet = (CallFrameIdSet | FunctionNameSet | LocationSet | ScopeChainSet | ThisSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CallFrame> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CallFrame;
    public:

        Builder<STATE | CallFrameIdSet>& setCallFrameId(/*const TypeBuilder::Debugger::CallFrameId&*/ const String& value)
        {
            COMPILE_ASSERT(!(STATE & CallFrameIdSet), property_callFrameId_already_set);
            m_result->setString("callFrameId", value);
            return castState<CallFrameIdSet>();
        }

        Builder<STATE | FunctionNameSet>& setFunctionName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & FunctionNameSet), property_functionName_already_set);
            m_result->setString("functionName", value);
            return castState<FunctionNameSet>();
        }

        Builder<STATE | LocationSet>& setLocation(/*PassRefPtr<TypeBuilder::Debugger::Location>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & LocationSet), property_location_already_set);
            m_result->setObject("location", value);
            return castState<LocationSet>();
        }

        Builder<STATE | ScopeChainSet>& setScopeChain(/*PassRefPtr<TypeBuilder::Array<TypeBuilder::Debugger::Scope> >*/ PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & ScopeChainSet), property_scopeChain_already_set);
            m_result->setArray("scopeChain", value);
            return castState<ScopeChainSet>();
        }

        Builder<STATE | ThisSet>& setThis(/*PassRefPtr<TypeBuilder::Runtime::RemoteObject>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & ThisSet), property_this_already_set);
            m_result->setObject("this", value);
            return castState<ThisSet>();
        }

        operator RefPtr<CallFrame>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CallFrame>*>(&m_result);
        }

        operator PassRefPtr<CallFrame> ()
        {
            return RefPtr<CallFrame>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CallFrame> result = CallFrame::create()
     *     .setCallFrameId(...)
     *     .setFunctionName(...)
     *     .setLocation(...)
     *     .setScopeChain(...)
     *     .setThis(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new CallFrame()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
    static PassRefPtr<CallFrame> runtimeCast(PassRefPtr<InspectorValue> value)
    {
        RefPtr<InspectorObject> object;
        bool castRes = value->asObject(&object);
        ASSERT_UNUSED(castRes, castRes);
#if !ASSERT_DISABLED
        assertCorrectValue(object.get());
#endif  // !ASSERT_DISABLED
        COMPILE_ASSERT(sizeof(CallFrame) == sizeof(InspectorObject), type_cast_problem);
        return static_cast<CallFrame*>(object.get());
    }

#if !ASSERT_DISABLED
    static void assertCorrectValue(InspectorValue* value);
#endif  // !ASSERT_DISABLED
};

/* Scope description. */
class Scope : public InspectorObject {
public:
    // Named after property name 'type' while generating Scope.
    struct Type {
        enum Enum {
            Global = 52,
            Local = 53,
            With = 54,
            Closure = 55,
            Catch = 56,
        };
#if !ASSERT_DISABLED
        static void assertCorrectValue(InspectorValue* value);
#endif  // !ASSERT_DISABLED
    }; // struct Type

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        ObjectSet = 1 << 1,
        AllFieldsSet = (TypeSet | ObjectSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Scope> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Scope;
    public:

        Builder<STATE | TypeSet>& setType(Type::Enum value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type", TypeBuilder::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString("type", value);
            return castState<TypeSet>();
        }

        Builder<STATE | ObjectSet>& setObject(/*PassRefPtr<TypeBuilder::Runtime::RemoteObject>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & ObjectSet), property_object_already_set);
            m_result->setObject("object", value);
            return castState<ObjectSet>();
        }

        operator RefPtr<Scope>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Scope>*>(&m_result);
        }

        operator PassRefPtr<Scope> ()
        {
            return RefPtr<Scope>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Scope> result = Scope::create()
     *     .setType(...)
     *     .setObject(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(adoptRef(new Scope()));
    }
    typedef TypeBuilder::StructItemTraits ItemTraits;
#if !ASSERT_DISABLED
    static void assertCorrectValue(InspectorValue* value);
#endif  // !ASSERT_DISABLED
};

} // Debugger

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
#if ENABLE(JAVASCRIPT_DEBUGGER)
namespace DOMDebugger {
/* DOM breakpoint type. */
struct DOMBreakpointType {
    enum Enum {
        Subtree_modified = 57,
        Attribute_modified = 58,
        Node_removed = 59,
    };
}; // struct DOMBreakpointType

} // DOMDebugger

#endif // ENABLE(JAVASCRIPT_DEBUGGER)

} // namespace TypeBuilder


} // namespace WebCore

#endif // ENABLE(INSPECTOR)

#endif // !defined(InspectorTypeBuilder_h)

